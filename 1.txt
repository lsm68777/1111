#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸ§  BRAIN SERVICE ULTIMATE - Phoenix 95 Signal Intelligence Engine (í¬íŠ¸: 8100)
================================================================================
ì—­í• : Phoenix 95 AI ë¶„ì„ + ì‹ í˜¸ ì²˜ë¦¬ í†µí•© + Pine Script IQE-V3 ì—°ë™ + ğŸ»ğŸ‚ Bear/Bull Market íŠ¹í™”
ê¸°ëŠ¥: 85% ì´ìƒ ì‹ ë¢°ë„ ì‹ í˜¸ë§Œ í†µê³¼, Kelly Criterion í¬ì§€ì…˜ ì‚¬ì´ì§•, ì–‘ë°©í–¥ ì‹œì¥ ê°ì§€ ë° ìµœì í™”
ê³ ë„í™”: RabbitMQ ë©”ì‹œì§€ ë°œí–‰, Redis Streams ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°, TradingView ì›¹í›…
ì™„ì „ì²´: HMM ì²´ì œ ê°ì§€ + Dynamic Position Sizing + ëŒ€ì¹­ì  Bull/Bear ë¶„ì„
================================================================================
"""

import asyncio
import json
import time
import logging
import hashlib
import hmac
import numpy as np
import redis
import aioredis
import pika
import aio_pika
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict, field
from collections import deque
import traceback
import gc
import psutil
import os
import sys
from pathlib import Path

# FastAPI ë° ì›¹ í”„ë ˆì„ì›Œí¬
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Security, status, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.responses import JSONResponse, HTMLResponse
from pydantic import BaseModel, Field, validator
import uvicorn

# ğŸ†• HMM ì²´ì œ ê°ì§€ìš© ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€
try:
    from hmmlearn import GaussianHMM
    HMM_AVAILABLE = True
    logging.info("ğŸ“Š HMM ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì„±ê³µ")
except ImportError:
    HMM_AVAILABLE = False
    logging.warning("ğŸ“Š hmmlearn ì—†ìŒ - HMM ì²´ì œ ê°ì§€ ë¹„í™œì„±í™”")
    logging.info("ì„¤ì¹˜: pip install hmmlearn")

# âœ… try: êµ¬ë¬¸ ì¶”ê°€ (í•„ìˆ˜!)
try:
    import asyncpg
    POSTGRES_AVAILABLE = True
    logging.info("ğŸ—„ï¸ PostgreSQL ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì„±ê³µ")
except ImportError:
    logging.warning("ğŸ—„ï¸ asyncpg ì—†ìŒ - PostgreSQL ê¸°ëŠ¥ ë¹„í™œì„±í™”")

# âœ… ì¸ì½”ë”© í•´ê²° ì½”ë“œ - ì™„ë²½í•œ ìœ„ì¹˜!
os.environ['PYTHONIOENCODING'] = 'utf-8'
if hasattr(sys.stdout, 'reconfigure'):
    sys.stdout.reconfigure(encoding='utf-8', errors='ignore')
print("[Phoenix95] Brain Service ULTIMATE - ì¸ì½”ë”© ì„¤ì • ì™„ë£Œ ğŸ»ğŸ‚ğŸ“Šâš¡")

import logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)],
    force=True
)
print("[Phoenix95] Brain Service ULTIMATE - logging ì¬ì„¤ì • ì™„ë£Œ ğŸ»ğŸ‚ğŸ“Šâš¡")

# =============================================================================
# ğŸ» ì‹œì¥ ì²´ì œ ê°ì§€ í´ë˜ìŠ¤ (í•˜ë½ì¥ íŠ¹í™”)
# =============================================================================

class MarketRegimeDetector:
    """ğŸ» ì‹œì¥ ì²´ì œ ê°ì§€ - í•˜ë½ì¥ íŠ¹í™” + ğŸ¯ HMM ê³ ë„í™”"""
    
    def __init__(self):
        self.price_history = deque(maxlen=100)
        self.volume_history = deque(maxlen=100)
        self.rsi_history = deque(maxlen=100)
        
        # ğŸ†• HMM ëª¨ë¸ ì´ˆê¸°í™”
        self.hmm_model = None
        self.hmm_data_ready = False
        self.last_hmm_update = 0
        
        if HMM_AVAILABLE:
            try:
                # 3ê°œ ìƒíƒœ: í•˜ë½ì¥(0), íš¡ë³´ì¥(1), ìƒìŠ¹ì¥(2)
                self.hmm_model = GaussianHMM(n_components=3, covariance_type="full", random_state=42)
                logging.info("ğŸ“Š HMM ëª¨ë¸ ì´ˆê¸°í™” ì„±ê³µ")
            except Exception as e:
                logging.warning(f"ğŸ“Š HMM ëª¨ë¸ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                self.hmm_model = None
        
    def detect_market_regime(self, signal_data: Dict) -> str:
        """ğŸ¯ ì‹œì¥ ì²´ì œ ê°ì§€ (HMM + ê¸°ì¡´ ë°©ì‹ ê²°í•©)"""
        price = signal_data.get("price", 0)
        volume = signal_data.get("volume", 0)
        rsi = signal_data.get("rsi", 50)
        
        # íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
        self.price_history.append(price)
        self.volume_history.append(volume)
        self.rsi_history.append(rsi)
        
        if len(self.price_history) < 20:
            return "UNKNOWN"
        
        # ğŸ†• HMM ê¸°ë°˜ ì²´ì œ ê°ì§€ (ìš°ì„ ìˆœìœ„)
        hmm_regime = self._detect_regime_hmm()
        if hmm_regime != "UNKNOWN":
            return hmm_regime
        
        # ê¸°ì¡´ ë°©ì‹ (HMM ì‹¤íŒ¨ì‹œ ë°±ì—…)
        return self._detect_regime_traditional(price, volume, rsi)
    
    def _detect_regime_hmm(self) -> str:
        """ğŸ¯ HMM ê¸°ë°˜ ì²´ì œ ê°ì§€"""
        if not HMM_AVAILABLE or not self.hmm_model or len(self.price_history) < 30:
            return "UNKNOWN"
        
        try:
            # 30ì´ˆë§ˆë‹¤ HMM ì—…ë°ì´íŠ¸ (ì„±ëŠ¥ ìµœì í™”)
            current_time = time.time()
            if current_time - self.last_hmm_update < 30:
                if hasattr(self, '_last_hmm_result'):
                    return self._last_hmm_result
            
            # íŠ¹ì„± ë²¡í„° ìƒì„± (ê°€ë²¼ìš´ ê³„ì‚°)
            recent_prices = list(self.price_history)[-30:]
            recent_volumes = list(self.volume_history)[-30:]
            recent_rsi = list(self.rsi_history)[-30:]
            
            # ìˆ˜ìµë¥  ê³„ì‚° (ê°„ë‹¨í•œ ì°¨ë¶„)
            returns = [(recent_prices[i] - recent_prices[i-1]) / recent_prices[i-1] 
                      for i in range(1, len(recent_prices))]
            
            # ì •ê·œí™”ëœ ê±°ë˜ëŸ‰ (ë¡œê·¸ ë³€í™˜)
            log_volumes = [np.log(max(v, 1)) for v in recent_volumes]
            
            # RSI ì •ê·œí™”
            normalized_rsi = [(r - 50) / 50 for r in recent_rsi]
            
            # íŠ¹ì„± í–‰ë ¬ ìƒì„± (29ê°œ ìƒ˜í”Œ x 3ê°œ íŠ¹ì„±)
            features = np.column_stack([
                returns,
                log_volumes[1:],  # ìˆ˜ìµë¥ ê³¼ ê¸¸ì´ ë§ì¶¤
                normalized_rsi[1:]
            ])
            
            # NaN ê°’ ì²˜ë¦¬
            if np.isnan(features).any():
                return "UNKNOWN"
            
            # HMM í•™ìŠµ (ë¹ ë¥¸ ì²˜ë¦¬: ~0.1ì´ˆ)
            self.hmm_model.fit(features)
            
            # í˜„ì¬ ìƒíƒœ ì˜ˆì¸¡
            current_state = self.hmm_model.predict(features[-5:])[-1]  # ìµœê·¼ 5ê°œ ìƒ˜í”Œì˜ ë§ˆì§€ë§‰ ìƒíƒœ
            
            # ìƒíƒœ ë§¤í•‘: 0=í•˜ë½ì¥, 1=íš¡ë³´ì¥, 2=ìƒìŠ¹ì¥
            regime_map = {0: "BEAR_MARKET", 1: "SIDEWAYS", 2: "BULL_MARKET"}
            result = regime_map.get(current_state, "UNKNOWN")
            
            # ìºì‹œ ì €ì¥
            self._last_hmm_result = result
            self.last_hmm_update = current_time
            
            logging.info(f"ğŸ“Š HMM ì²´ì œ ê°ì§€: {result} (State: {current_state})")
            return result
            
        except Exception as e:
            logging.warning(f"ğŸ“Š HMM ì²´ì œ ê°ì§€ ì‹¤íŒ¨: {e}")
            return "UNKNOWN"
    
    def _detect_regime_traditional(self, price: float, volume: float, rsi: float) -> str:
        """ğŸ» ê¸°ì¡´ ë°©ì‹ ì²´ì œ ê°ì§€ (HMM ë°±ì—…)"""
        # ìµœê·¼ 20ê°œ ê°€ê²©ì˜ ì´ë™í‰ê·  ê³„ì‚°
        recent_prices = list(self.price_history)[-20:]
        sma_20 = sum(recent_prices) / len(recent_prices)
        
        # í•˜ë½ íŠ¸ë Œë“œ ê°ì§€
        price_trend = (price - sma_20) / sma_20
        
        # ê±°ë˜ëŸ‰ ë¶„ì„
        recent_volumes = list(self.volume_history)[-10:]
        avg_volume = sum(recent_volumes) / len(recent_volumes) if recent_volumes else 0
        volume_spike = volume / avg_volume if avg_volume > 0 else 1
        
        # í•˜ë½ì¥ ì¡°ê±´ë“¤
        bear_signals = 0
        bull_signals = 0
        
        if price_trend < -0.02:  # 2% ì´í•˜ SMA
            bear_signals += 1
        elif price_trend > 0.02:  # 2% ì´ìƒ SMA
            bull_signals += 1
            
        if rsi < 45:  # RSI ì•½ì„¸
            bear_signals += 1
        elif rsi > 55:  # RSI ê°•ì„¸
            bull_signals += 1
            
        if volume_spike > 1.2 and price_trend < 0:  # í•˜ë½ + ê±°ë˜ëŸ‰ ì¦ê°€
            bear_signals += 1
        elif volume_spike > 1.2 and price_trend > 0:  # ìƒìŠ¹ + ê±°ë˜ëŸ‰ ì¦ê°€
            bull_signals += 1
        
        # ì‹œì¥ ì²´ì œ íŒì •
        if bear_signals >= 2:
            return "BEAR_MARKET"
        elif bull_signals >= 2:
            return "BULL_MARKET"
        else:
            return "SIDEWAYS"

# =============================================================================
# ğŸ‚ ìƒìŠ¹ì¥ ì „ìš© ë¶„ì„ê¸° (NEW!)
# =============================================================================

class BullMarketAnalyzer:
    """ğŸ‚ ìƒìŠ¹ì¥ ì „ìš© ê³ ê¸‰ ë¶„ì„ê¸°"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.price_history = deque(maxlen=100)
        self.volume_history = deque(maxlen=100)
        self.rsi_history = deque(maxlen=50)
        self.greed_index = 0.5  # íƒìš• ì§€ìˆ˜ (0: ê·¹ë„ ê³µí¬, 1: ê·¹ë„ íƒìš•)
        
    def analyze_bull_signals(self, signal) -> Tuple[float, Dict]:
        """ğŸ‚ ìƒìŠ¹ì¥ ì „ìš© ì‹ í˜¸ ë¶„ì„ (í–¥ìƒëœ ë²„ì „)"""
        bull_score = 0.0
        bull_details = {}
        
        try:
            # ë°ì´í„° íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
            if signal.price:
                self.price_history.append(signal.price)
            if signal.volume:
                self.volume_history.append(signal.volume)
            if signal.rsi:
                self.rsi_history.append(signal.rsi)
            
            # 1. RSI ê³¼ë§¤ë„ì—ì„œ ë°˜ë“± ì‹ í˜¸ (Enhanced)
            if signal.rsi and signal.rsi < 45:  # RSI ë‚®ì„ ë•Œ Long ê°•í™”
                rsi_intensity = (50 - signal.rsi) / 50
                rsi_long_signal = min(rsi_intensity * 0.35, 0.35)  # ìµœëŒ€ 35% ë¶€ìŠ¤íŠ¸
                
                # RSI íˆìŠ¤í† ë¦¬ ê¸°ë°˜ ë°˜ë“± ê°ì§€
                if len(self.rsi_history) >= 10:
                    rsi_trend = np.polyfit(range(10), list(self.rsi_history)[-10:], 1)[0]
                    if rsi_trend < -0.5 and signal.action.lower() in ["buy", "long"]:
                        rsi_long_signal *= 1.2  # ì¶”ê°€ 20% ë¶€ìŠ¤íŠ¸
                
                bull_score += rsi_long_signal
                bull_details["rsi_oversold_bounce"] = {
                    "signal": rsi_long_signal,
                    "rsi_value": signal.rsi,
                    "intensity": rsi_intensity
                }
            
            # 2. ì €í•­ì„  ëŒíŒŒ ê°ì§€ (Enhanced)
            if signal.bollinger_upper and signal.price:
                if signal.price > signal.bollinger_upper:
                    # ëŒíŒŒ ê°•ë„ ê³„ì‚°
                    breakout_intensity = (signal.price - signal.bollinger_upper) / signal.bollinger_upper
                    resistance_break = min(breakout_intensity * 2, 0.4)  # ìµœëŒ€ 40%
                    
                    bull_score += resistance_break
                    bull_details["resistance_breakout"] = {
                        "signal": resistance_break,
                        "breakout_intensity": breakout_intensity,
                        "price": signal.price,
                        "resistance_level": signal.bollinger_upper
                    }
            
            # 3. ê±°ë˜ëŸ‰ FOMO ë§¤ìˆ˜ ë¶„ì„ (Enhanced)
            if signal.volume and signal.volume > self.config.get("volume_fomo_threshold", 5000000):
                # ê±°ë˜ëŸ‰ ìŠ¤íŒŒì´í¬ ì •ë„
                avg_volume = np.mean(list(self.volume_history)[-20:]) if len(self.volume_history) >= 20 else signal.volume
                volume_spike_ratio = signal.volume / avg_volume if avg_volume > 0 else 1
                
                # FOMO ë§¤ìˆ˜ ì ìˆ˜ (ê±°ë˜ëŸ‰ ê¸‰ì¦ + ê°€ê²© ìƒìŠ¹)
                if len(self.price_history) >= 2:
                    price_change = (signal.price - self.price_history[-2]) / self.price_history[-2]
                    if price_change > 0.01:  # 1% ì´ìƒ ìƒìŠ¹
                        volume_fomo = min(volume_spike_ratio / 10 * price_change * 10, 0.25)
                        bull_score += volume_fomo
                        bull_details["volume_fomo"] = {
                            "signal": volume_fomo,
                            "volume_spike_ratio": volume_spike_ratio,
                            "price_change": price_change
                        }
            
            # 4. MACD ìƒìŠ¹ ì‹ í˜¸ (Enhanced)
            if signal.macd and signal.macd > self.config.get("macd_bullish_threshold", 0.001):
                macd_intensity = signal.macd / 0.01  # 0.01 ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
                macd_bull = min(macd_intensity * 0.3, 0.3)  # ìµœëŒ€ 30%
                
                bull_score += macd_bull
                bull_details["macd_bullish"] = {
                    "signal": macd_bull,
                    "macd_value": signal.macd,
                    "intensity": macd_intensity
                }
            
            # 5. ğŸ†• íƒìš• ì§€ìˆ˜ ì—…ë°ì´íŠ¸ ë° í™œìš©
            self._update_greed_index(signal)
            greed_boost = (1 - self.greed_index) * 0.15  # íƒìš• ë‚®ì„ ë•Œ ê¸°íšŒ
            bull_score += greed_boost
            bull_details["greed_index"] = {
                "current_greed": self.greed_index,
                "greed_boost": greed_boost
            }
            
            # 6. ğŸ†• ì—°ì† ìƒìŠ¹ íŒ¨í„´ ê°ì§€
            consecutive_rise = self._detect_consecutive_rise()
            if consecutive_rise > 0:
                rise_boost = min(consecutive_rise * 0.05, 0.2)  # ìµœëŒ€ 20%
                bull_score += rise_boost
                bull_details["consecutive_rise"] = {
                    "periods": consecutive_rise,
                    "boost": rise_boost
                }
            
            bull_details["total_bull_score"] = min(bull_score, 1.0)
            return min(bull_score, 1.0), bull_details
            
        except Exception as e:
            logging.error(f"ìƒìŠ¹ì¥ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 0.0, {"error": str(e)}
    
    def _update_greed_index(self, signal):
        """íƒìš• ì§€ìˆ˜ ì—…ë°ì´íŠ¸"""
        try:
            greed_factors = []
            
            # RSI ê¸°ë°˜ íƒìš•ë„
            if signal.rsi:
                if signal.rsi > 70:
                    greed_factors.append(0.8)  # ê³¼ë§¤ìˆ˜ì‹œ íƒìš• ì¦ê°€
                elif signal.rsi < 30:
                    greed_factors.append(0.2)  # ê³¼ë§¤ë„ì‹œ íƒìš• ê°ì†Œ
            
            # ê°€ê²© ìƒìŠ¹ë¥  ê¸°ë°˜
            if len(self.price_history) >= 5:
                recent_prices = list(self.price_history)[-5:]
                price_momentum = (recent_prices[-1] - recent_prices[0]) / recent_prices[0]
                if price_momentum > 0.02:  # 2% ì´ìƒ ìƒìŠ¹ì‹œ íƒìš• ì¦ê°€
                    greed_factors.append(0.7)
            
            # ê±°ë˜ëŸ‰ ê¸°ë°˜
            if signal.volume and len(self.volume_history) >= 10:
                avg_volume = np.mean(list(self.volume_history)[-10:])
                volume_ratio = signal.volume / avg_volume if avg_volume > 0 else 1
                if volume_ratio > 2:  # ê±°ë˜ëŸ‰ 2ë°° ì´ìƒ ì¦ê°€ì‹œ
                    greed_factors.append(0.6)
            
            # íƒìš• ì§€ìˆ˜ ì—…ë°ì´íŠ¸ (ì´ë™í‰ê·  ë°©ì‹)
            if greed_factors:
                new_greed = np.mean(greed_factors)
                self.greed_index = self.greed_index * 0.8 + new_greed * 0.2
            
        except Exception as e:
            logging.error(f"íƒìš• ì§€ìˆ˜ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def _detect_consecutive_rise(self) -> int:
        """ì—°ì† ìƒìŠ¹ ê¸°ê°„ ê°ì§€"""
        if len(self.price_history) < 5:
            return 0
        
        consecutive_count = 0
        recent_prices = list(self.price_history)[-10:]  # ìµœê·¼ 10ê°œ ê°€ê²©
        
        for i in range(len(recent_prices) - 1, 0, -1):
            if recent_prices[i] > recent_prices[i-1]:
                consecutive_count += 1
            else:
                break
        
        return consecutive_count

# =============================================================================
# ğŸ¯ BRAIN ì„œë¹„ìŠ¤ ì„¤ì • (ULTIMATE)
# =============================================================================

@dataclass
class BrainServiceConfig:
    """ğŸ§  BRAIN ì„œë¹„ìŠ¤ ì „ìš© ì„¤ì • - ULTIMATE ë²„ì „"""
    
    # ì„œë¹„ìŠ¤ ê¸°ë³¸ ì •ë³´
    SERVICE_NAME: str = "BRAIN"
    SERVICE_PORT: int = 8100
    SERVICE_VERSION: str = "5.0.0-BRAIN-ULTIMATE-BULL-BEAR-HMM-DYNAMIC"
    
    # Phoenix 95 AI ì—”ì§„ ì„¤ì •
    PHOENIX_95_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "confidence_threshold": 0.65,      # 65% ì´ìƒë§Œ í†µê³¼
        "analysis_timeout": 2.0,           # 2ì´ˆ ì´ë‚´ ë¶„ì„ ì™„ë£Œ
        "cache_duration": 300,             # 5ë¶„ ìºì‹œ
        "batch_size": 50,                  # ë°°ì¹˜ ì²˜ë¦¬ í¬ê¸°
        "max_concurrent": 100,             # ìµœëŒ€ ë™ì‹œ ì²˜ë¦¬
        "retry_attempts": 3,               # ì¬ì‹œë„ íšŸìˆ˜
        "quality_threshold": 0.75,         # í’ˆì§ˆ ì„ê³„ê°’
        "model_ensemble": True,            # ì•™ìƒë¸” ëª¨ë¸ ì‚¬ìš©
        "real_time_validation": True       # ì‹¤ì‹œê°„ ê²€ì¦
    })
    
    # Kelly Criterion ì„¤ì •
    KELLY_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "max_kelly_fraction": 0.02,        # ìµœëŒ€ 2% í¬ì§€ì…˜
        "min_kelly_fraction": 0.01,        # ìµœì†Œ 1% í¬ì§€ì…˜
        "win_rate_adjustment": 0.85,       # ìŠ¹ë¥  ì¡°ì • ê³„ìˆ˜
        "risk_free_rate": 0.02,            # ë¬´ìœ„í—˜ ìˆ˜ìµë¥ 
        "volatility_penalty": 0.1,         # ë³€ë™ì„± íŒ¨ë„í‹°
        "confidence_boost": 1.2            # ì‹ ë¢°ë„ ë¶€ìŠ¤íŠ¸
    })
    
    # ğŸ» í•˜ë½ì¥ ì„¤ì •
    BEAR_MARKET_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "detection_threshold": 0.7,
        "short_boost_factor": 1.2,
        "long_penalty_factor": 0.85,
        "bear_signal_weight": 0.085
    })
    
    # ğŸ‚ ìƒìŠ¹ì¥ ì„¤ì • (NEW!)
    BULL_MARKET_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "detection_threshold": 0.7,        # ìƒìŠ¹ì¥ ê°ì§€ ì„ê³„ê°’
        "long_boost_factor": 1.2,          # Long ì‹ í˜¸ ë¶€ìŠ¤íŠ¸
        "short_penalty_factor": 0.85,      # Short ì‹ í˜¸ í˜ë„í‹°
        "bull_signal_weight": 0.085,       # ìƒìŠ¹ì¥ ì‹ í˜¸ ê°€ì¤‘ì¹˜
        "volume_fomo_threshold": 5000000,  # FOMO ë§¤ìˆ˜ ê±°ë˜ëŸ‰ ì„ê³„ê°’
        "rsi_oversold_threshold": 45,      # RSI ê³¼ë§¤ë„ ì„ê³„ê°’
        "macd_bullish_threshold": 0.001    # MACD ìƒìŠ¹ ì„ê³„ê°’
    })
    
    # ë©”ì‹œì§€ í ì„¤ì • (RabbitMQ)
    RABBITMQ_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "host": "localhost",
        "port": 5672,
        "username": "phoenix95",
        "password": "secure_password_2025",
        "virtual_host": "/trading",
        "exchange": "phoenix95.brain.analysis",
        "routing_key": "signal.analyzed",
        "queue": "analyzed_signals",
        "durable": True,
        "auto_delete": False
    })
    
    # Redis Streams ì„¤ì •
    REDIS_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "host": "localhost",
        "port": 6379,
        "db": 1,
        "stream_name": "brain:analysis:stream",
        "consumer_group": "brain_processors",
        "consumer_name": "brain-worker-1",
        "max_len": 10000,
        "block_ms": 1000
    })
    
    # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì„¤ì •
    MONITORING_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "metrics_interval": 30,            # 30ì´ˆë§ˆë‹¤ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        "health_check_interval": 10,       # 10ì´ˆë§ˆë‹¤ í—¬ìŠ¤ì²´í¬
        "alert_thresholds": {
            "memory_percent": 80,
            "cpu_percent": 85,
            "queue_size": 1000,
            "error_rate": 5.0,
            "response_time_ms": 2000
        }
    })
    
    # í…”ë ˆê·¸ë¨ ì„¤ì •
    TELEGRAM_CONFIG: Dict[str, Any] = field(default_factory=lambda: {
        "token": "7386542811:AAEZ21p30rES1k8NxNM2xbZ53U44PI9D5CY",
        "chat_id": "7590895952",
        "enabled": True,
        "alert_level": "WARNING"
    })

# =============================================================================
# ğŸ“Š ë°ì´í„° ëª¨ë¸ (ULTIMATE)
# =============================================================================

@dataclass
class SignalData:
    """ì‹ í˜¸ ë°ì´í„° ëª¨ë¸ - Pine Script IQE-V3 ì—°ë™ ì§€ì›"""
    signal_id: str
    symbol: str
    action: str
    price: float
    confidence: float
    timestamp: datetime
    
    # ê¸°ì¡´ ê¸°ìˆ ì  ì§€í‘œ
    rsi: Optional[float] = None
    macd: Optional[float] = None
    bollinger_upper: Optional[float] = None
    bollinger_lower: Optional[float] = None
    volume: Optional[float] = None
    
    # ğŸ†• Pine Script IQE-V3 ì „ìš© í•„ë“œë“¤
    alpha_score: Optional[float] = None      # Alpha ì ìˆ˜ (IQE-V3 í•µì‹¬ ì§€í‘œ)
    z_score: Optional[float] = None          # Z-Score (ì •ê·œí™”ëœ ì ìˆ˜)
    ml_signal: Optional[float] = None        # ML ì‹ í˜¸ ê°•ë„
    ml_confidence: Optional[str] = None      # ML ì‹ ë¢°ë„ ë ˆë²¨
    
    # ì¶”ê°€ ì •ë³´
    strategy: Optional[str] = None
    timeframe: Optional[str] = None
    source: Optional[str] = None
    
    def to_dict(self) -> Dict:
        return asdict(self)

@dataclass
class AnalysisResult:
    """ë¶„ì„ ê²°ê³¼ ëª¨ë¸ - ULTIMATE ë²„ì „"""
    signal_id: str
    symbol: str
    
    # ë¶„ì„ ì ìˆ˜
    phoenix95_score: float
    quality_score: float
    final_confidence: float
    
    # ğŸ†• ì‹œì¥ë³„ ì ìˆ˜
    bear_market_score: float
    bull_market_score: float
    regime_confidence: float
    
    # Kelly Criterion ê²°ê³¼
    kelly_fraction: float
    position_size: float
    
    # ë¦¬ìŠ¤í¬ í‰ê°€
    risk_level: str
    risk_score: float
    
    # ì‹¤í–‰ ê¶Œì¥
    recommendation: str
    execution_timing: str
    urgency: int
    
    # ë©”íƒ€ë°ì´í„°
    analysis_time_ms: float
    cache_hit: bool
    model_used: str
    
    # ìƒì„¸ ë¶„ì„
    technical_analysis: Dict = field(default_factory=dict)
    market_conditions: Dict = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        return asdict(self)

class SignalRequest(BaseModel):
    """ì‹ í˜¸ ìš”ì²­ ëª¨ë¸"""
    symbol: str = Field(..., description="ê±°ë˜ ì‹¬ë³¼")
    action: str = Field(..., description="ê±°ë˜ ë°©í–¥")
    price: float = Field(..., gt=0, description="ê°€ê²©")
    confidence: float = Field(0.8, ge=0, le=1, description="ì‹ ë¢°ë„")
    strategy: Optional[str] = Field(None, description="ì „ëµëª…")
    timeframe: Optional[str] = Field("1h", description="ì‹œê°„í”„ë ˆì„")
    rsi: Optional[float] = Field(None, description="RSI ì§€í‘œ")
    macd: Optional[float] = Field(None, description="MACD ì§€í‘œ")
    volume: Optional[float] = Field(None, description="ê±°ë˜ëŸ‰")
    
    # Pine Script IQE-V3 í•„ë“œë“¤
    alpha_score: Optional[float] = Field(None, description="Alpha ì ìˆ˜")
    z_score: Optional[float] = Field(None, description="Z-Score")
    ml_signal: Optional[float] = Field(None, description="ML ì‹ í˜¸")
    ml_confidence: Optional[str] = Field(None, description="ML ì‹ ë¢°ë„")
    
    @validator('action')
    def validate_action(cls, v):
        if v.lower() not in ['buy', 'sell', 'long', 'short']:
            raise ValueError('action must be buy, sell, long, or short')
        return v.lower()
    
    @validator('symbol')
    def validate_symbol(cls, v):
        return v.upper().strip()

# =============================================================================
# ğŸ§  Phoenix 95 AI Engine Core ULTIMATE (Bull + Bear + HMM + Dynamic)
# =============================================================================

class Phoenix95AIEngine:
    """ğŸ§  Phoenix 95 AI ì—”ì§„ - BRAIN ì„œë¹„ìŠ¤ ì½”ì–´ ULTIMATE + ğŸ»ğŸ‚ ì–‘ë°©í–¥ ì‹œì¥ íŠ¹í™”"""
    
    def __init__(self, config: BrainServiceConfig):
        self.config = config
        self.phoenix_config = config.PHOENIX_95_CONFIG
        self.kelly_config = config.KELLY_CONFIG
        self.bear_config = config.BEAR_MARKET_CONFIG
        self.bull_config = config.BULL_MARKET_CONFIG  # ğŸ†• ìƒìŠ¹ì¥ ì„¤ì •
        
        # ğŸ†• ì „ì²´ ë¶„ì„ ì»´í¬ë„ŒíŠ¸
        self.market_detector = MarketRegimeDetector()
        self.bull_analyzer = BullMarketAnalyzer(self.bull_config)  # ğŸ†• ìƒìŠ¹ì¥ ë¶„ì„ê¸°
        
        # ìºì‹œ ì‹œìŠ¤í…œ
        self.analysis_cache = {}
        self.market_data_cache = {}
        
        # ì„±ëŠ¥ ì¶”ì  (ULTIMATE)
        self.performance_metrics = {
            "total_analyses": 0,
            "successful_analyses": 0,
            "cache_hits": 0,
            "avg_analysis_time": 0.0,
            "model_accuracy": 0.0,
            "pine_script_signals": 0,
            "bear_market_signals": 0,          # ğŸ» í•˜ë½ì¥ ì‹ í˜¸
            "bull_market_signals": 0,          # ğŸ‚ ìƒìŠ¹ì¥ ì‹ í˜¸ (NEW!)
            "bear_market_accuracy": 0.0,       # ğŸ» í•˜ë½ì¥ ì •í™•ë„
            "bull_market_accuracy": 0.0,       # ğŸ‚ ìƒìŠ¹ì¥ ì •í™•ë„ (NEW!)
            "hmm_detections": 0,               # ğŸ†• HMM ê°ì§€ íšŸìˆ˜
            "enhanced_bear_signals": 0,        # ğŸ†• í–¥ìƒëœ í•˜ë½ì¥ ì‹ í˜¸
            "enhanced_bull_signals": 0,        # ğŸ†• í–¥ìƒëœ ìƒìŠ¹ì¥ ì‹ í˜¸ (NEW!)
            "dynamic_kelly_adjustments": 0     # ğŸ†• ë™ì  ì¼ˆë¦¬ ì¡°ì •
        }
        
        # ëª¨ë¸ ê°€ì¤‘ì¹˜ (Phoenix 95 ìµœì í™” + ê· í˜•ì¡íŒ Bull/Bear)
        self.model_weights = {
            "technical_analysis": 0.18,       # ê¸°ìˆ ì  ë¶„ì„
            "market_sentiment": 0.13,         # ì‹œì¥ ì„¼í‹°ë©˜íŠ¸
            "volume_analysis": 0.12,          # ê±°ë˜ëŸ‰ ë¶„ì„
            "momentum_indicators": 0.12,      # ëª¨ë©˜í…€ ì§€í‘œ
            "pine_script_iqe": 0.20,          # Pine Script IQE-V3
            "hmm_regime_analysis": 0.08,      # HMM ì²´ì œ ë¶„ì„
            "bear_market_signals": 0.085,     # ğŸ» í•˜ë½ì¥ ì‹ í˜¸
            "bull_market_signals": 0.085      # ğŸ‚ ìƒìŠ¹ì¥ ì‹ í˜¸ (NEW!)
        }
        
        logging.info("ğŸ§  Phoenix 95 AI Engine ULTIMATE ì´ˆê¸°í™” ì™„ë£Œ (Pine + ğŸ»ğŸ‚ Bull/Bear + ğŸ“Š HMM + âš¡ Dynamic)")
    
    async def _analyze_bear_market_signals(self, signal: SignalData) -> Tuple[float, Dict]:
        """ğŸ» í•˜ë½ì¥ ì „ìš© ì‹ í˜¸ ë¶„ì„"""
        bear_score = 0.0
        bear_details = {}
        
        try:
            # RSI ì—­ë°œì‚° ê°ì§€
            if signal.rsi and signal.rsi > 60:
                # RSI ê³ ì ì—ì„œ Short ì‹ í˜¸ ê°•í™”
                rsi_short_signal = (signal.rsi - 50) / 50 * 0.3  # ìµœëŒ€ 30% ë¶€ìŠ¤íŠ¸
                bear_score += rsi_short_signal
                bear_details["rsi_divergence"] = rsi_short_signal
            
            # ì§€ì§€ì„  ì´íƒˆ ê°ì§€ (ë³¼ë¦°ì € ë°´ë“œ í•˜ë‹¨ ì´íƒˆ)
            if signal.bollinger_lower and signal.price:
                if signal.price < signal.bollinger_lower:
                    support_break = 0.4  # 40% ì ìˆ˜ ì¶”ê°€
                    bear_score += support_break
                    bear_details["support_breakdown"] = support_break
            
            # ê±°ë˜ëŸ‰ ê¸‰ì¦ + í•˜ë½ = ê³µí¬ ë§¤ë„
            if signal.volume and signal.volume > 5000000:  # í° ê±°ë˜ëŸ‰
                volume_panic = min(signal.volume / 10000000 * 0.2, 0.2)  # ìµœëŒ€ 20%
                bear_score += volume_panic
                bear_details["volume_panic"] = volume_panic
            
            # MACD í•˜ë½ ì‹ í˜¸
            if signal.macd and signal.macd < -0.001:
                macd_bear = abs(signal.macd) * 100  # MACD ìŒìˆ˜ê°’ í™œìš©
                bear_score += min(macd_bear, 0.3)
                bear_details["macd_bearish"] = min(macd_bear, 0.3)
            
            bear_details["total_bear_score"] = bear_score
            return min(bear_score, 1.0), bear_details
            
        except Exception as e:
            logging.error(f"í•˜ë½ì¥ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 0.0, {"error": str(e)}

    async def _enhanced_bear_signals_lightweight(self, signal: SignalData) -> Tuple[float, Dict]:
        """ğŸš€ í–¥ìƒëœ í•˜ë½ì¥ ë¶„ì„ (ê°„ì†Œí™” ê³ ì„±ëŠ¥ ë²„ì „)"""
        bear_score = 0.0
        enhanced_details = {}
        
        try:
            # ì²˜ë¦¬ì‹œê°„: ~0.001ì´ˆ âœ…
            
            # 1. RSI ê³¼ë§¤ìˆ˜ ì‹ í˜¸ (ê°„ë‹¨í•œ ì¡°ê±´ë¬¸)
            if signal.rsi and signal.rsi > 70:
                rsi_bear = 0.3
                bear_score += rsi_bear
                enhanced_details["rsi_overbought"] = rsi_bear
            elif signal.rsi and signal.rsi > 60:
                rsi_bear = 0.15
                bear_score += rsi_bear
                enhanced_details["rsi_warning"] = rsi_bear
            
            # 2. MACD í•˜ë½ ëª¨ë©˜í…€ (ê¸°ë³¸ ìˆ˜í•™ ì—°ì‚°)
            if signal.macd and signal.macd < -0.001:
                macd_bear = min(abs(signal.macd) * 200, 0.25)  # ìµœëŒ€ 25%
                bear_score += macd_bear
                enhanced_details["macd_bearish"] = macd_bear
            
            # 3. ê±°ë˜ëŸ‰ ìŠ¤íŒŒì´í¬ + í•˜ë½ (ë¹„êµ ì—°ì‚°)
            if signal.volume and signal.volume > 5000000:
                # ê°„ë‹¨í•œ ê±°ë˜ëŸ‰ ë¶„ì„
                volume_multiplier = min(signal.volume / 10000000, 2.0)  # ìµœëŒ€ 2ë°°
                volume_bear = volume_multiplier * 0.1  # ìµœëŒ€ 20%
                bear_score += volume_bear
                enhanced_details["volume_spike"] = volume_bear
            
            # 4. ê°€ê²© ëª¨ë©˜í…€ ë¶„ì„ (Pine Script ì—°ë™)
            if signal.alpha_score and signal.alpha_score < -0.3:
                alpha_bear = abs(signal.alpha_score) * 0.2  # ìµœëŒ€ 20%
                bear_score += alpha_bear
                enhanced_details["alpha_bearish"] = alpha_bear
            
            # 5. ML ì‹ í˜¸ í™•ì¸ (ê°„ë‹¨í•œ ë¹„êµ)
            if signal.ml_signal and signal.ml_signal < -0.5:
                ml_bear = abs(signal.ml_signal) * 0.15  # ìµœëŒ€ 15%
                bear_score += ml_bear
                enhanced_details["ml_bearish"] = ml_bear
            
            # 6. Z-Score ê·¹ê°’ ì²´í¬
            if signal.z_score and abs(signal.z_score) > 2.0:
                z_bear = min(abs(signal.z_score) / 5.0, 0.1)  # ìµœëŒ€ 10%
                bear_score += z_bear
                enhanced_details["z_extreme"] = z_bear
            
            # í–¥ìƒëœ ì‹ í˜¸ ì¶”ì 
            if bear_score > 0.3:
                self.performance_metrics["enhanced_bear_signals"] += 1
            
            enhanced_details["total_enhanced_score"] = bear_score
            enhanced_details["processing_time_ms"] = 0.001  # ë§¤ìš° ë¹ ë¦„
            
            return min(bear_score, 1.0), enhanced_details
            
        except Exception as e:
            logging.error(f"í–¥ìƒëœ í•˜ë½ì¥ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 0.0, {"error": str(e)}

    async def _enhanced_bull_signals_lightweight(self, signal: SignalData) -> Tuple[float, Dict]:
        """ğŸš€ í–¥ìƒëœ ìƒìŠ¹ì¥ ë¶„ì„ (ì´ˆê³ ì† ë²„ì „) - NEW!"""
        bull_score = 0.0
        enhanced_details = {}
        
        try:
            # ì²˜ë¦¬ì‹œê°„: ~0.001ì´ˆ âœ…
            
            # 1. RSI ê³¼ë§¤ë„ ì‹ í˜¸ (ê°„ë‹¨í•œ ì¡°ê±´ë¬¸)
            if signal.rsi and signal.rsi < 30:
                rsi_bull = 0.3  # RSI ê³¼ë§¤ë„ì‹œ ê°•í•œ ìƒìŠ¹ ì‹ í˜¸
                bull_score += rsi_bull
                enhanced_details["rsi_oversold"] = rsi_bull
            elif signal.rsi and signal.rsi < 40:
                rsi_bull = 0.15
                bull_score += rsi_bull
                enhanced_details["rsi_opportunity"] = rsi_bull
            
            # 2. MACD ìƒìŠ¹ ëª¨ë©˜í…€ (ê¸°ë³¸ ìˆ˜í•™ ì—°ì‚°)
            if signal.macd and signal.macd > 0.001:
                macd_bull = min(signal.macd * 200, 0.25)  # ìµœëŒ€ 25%
                bull_score += macd_bull
                enhanced_details["macd_bullish"] = macd_bull
            
            # 3. ê±°ë˜ëŸ‰ ìŠ¤íŒŒì´í¬ + ìƒìŠ¹ (ë¹„êµ ì—°ì‚°)
            if signal.volume and signal.volume > 5000000:
                # ê°„ë‹¨í•œ ê±°ë˜ëŸ‰ ë¶„ì„ (ìƒìŠ¹ í¸í–¥)
                volume_multiplier = min(signal.volume / 10000000, 2.0)  # ìµœëŒ€ 2ë°°
                volume_bull = volume_multiplier * 0.12  # ìµœëŒ€ 24% (ìƒìŠ¹ì¥ ìœ ë¦¬)
                bull_score += volume_bull
                enhanced_details["volume_spike"] = volume_bull
            
            # 4. ê°€ê²© ëª¨ë©˜í…€ ë¶„ì„ (Pine Script ì—°ë™)
            if signal.alpha_score and signal.alpha_score > 0.3:
                alpha_bull = signal.alpha_score * 0.2  # ìµœëŒ€ 20%
                bull_score += alpha_bull
                enhanced_details["alpha_bullish"] = alpha_bull
            
            # 5. ML ì‹ í˜¸ í™•ì¸ (ê°„ë‹¨í•œ ë¹„êµ)
            if signal.ml_signal and signal.ml_signal > 0.5:
                ml_bull = signal.ml_signal * 0.15  # ìµœëŒ€ 15%
                bull_score += ml_bull
                enhanced_details["ml_bullish"] = ml_bull
            
            # 6. Z-Score ê·¹ê°’ ì²´í¬ (ìƒìŠ¹ í¸í–¥)
            if signal.z_score and signal.z_score > 2.0:
                z_bull = min(signal.z_score / 5.0, 0.1)  # ìµœëŒ€ 10%
                bull_score += z_bull
                enhanced_details["z_positive_extreme"] = z_bull
            
            # 7. ğŸ†• ì €í•­ì„  ëŒíŒŒ ê°ì§€ (ë³¼ë¦°ì € ë°´ë“œ ìƒë‹¨ ëŒíŒŒ)
            if signal.bollinger_upper and signal.price and signal.price > signal.bollinger_upper:
                breakout_bull = 0.25  # ì €í•­ì„  ëŒíŒŒì‹œ 25% ë¶€ìŠ¤íŠ¸
                bull_score += breakout_bull
                enhanced_details["resistance_breakout"] = breakout_bull
            
            # í–¥ìƒëœ ì‹ í˜¸ ì¶”ì 
            if bull_score > 0.3:
                self.performance_metrics["enhanced_bull_signals"] += 1
            
            enhanced_details["total_enhanced_score"] = bull_score
            enhanced_details["processing_time_ms"] = 0.001  # ë§¤ìš° ë¹ ë¦„
            
            return min(bull_score, 1.0), enhanced_details
            
        except Exception as e:
            logging.error(f"í–¥ìƒëœ ìƒìŠ¹ì¥ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 0.0, {"error": str(e)}

    def _adjust_signal_for_market_regime(self, signal: SignalData, phoenix95_score: float, 
                                       market_regime: str, bear_score: float = 0.0, bull_score: float = 0.0) -> float:
        """ì‹œì¥ ì²´ì œì— ë”°ë¥¸ ì‹ í˜¸ ì¡°ì • (ULTIMATE - Bull/Bear ëŒ€ì¹­)"""
        
        if market_regime == "BEAR_MARKET":
            # í•˜ë½ì¥ì—ì„œ Short ì‹ í˜¸ ê°•í™”
            if signal.action.lower() in ["sell", "short"]:
                # Bear scoreê°€ ë†’ì„ìˆ˜ë¡ ë” í° ë¶€ìŠ¤íŠ¸
                boost_factor = self.bear_config["short_boost_factor"]
                if bear_score > 0.7:
                    boost_factor *= 1.1  # ì¶”ê°€ 10% ë¶€ìŠ¤íŠ¸
                
                boosted_score = phoenix95_score * boost_factor
                logging.info(f"ğŸ» í•˜ë½ì¥ Short ë¶€ìŠ¤íŠ¸: {phoenix95_score:.3f} -> {boosted_score:.3f}")
                return min(boosted_score, 0.95)
            
            # í•˜ë½ì¥ì—ì„œ Long ì‹ í˜¸ í˜ë„í‹°
            elif signal.action.lower() in ["buy", "long"]:
                penalty_factor = self.bear_config["long_penalty_factor"]
                if bear_score > 0.6:
                    penalty_factor *= 0.95  # ì¶”ê°€ 5% ê°ì†Œ
                
                penalized_score = phoenix95_score * penalty_factor
                logging.warning(f"ğŸ» í•˜ë½ì¥ Long í˜ë„í‹°: {phoenix95_score:.3f} -> {penalized_score:.3f}")
                return penalized_score
        
        elif market_regime == "BULL_MARKET":
            # ìƒìŠ¹ì¥ì—ì„œ Long ì‹ í˜¸ ê°•í™” (ğŸ†• ëŒ€ì¹­ êµ¬ì¡°)
            if signal.action.lower() in ["buy", "long"]:
                # Bull scoreê°€ ë†’ì„ìˆ˜ë¡ ë” í° ë¶€ìŠ¤íŠ¸
                boost_factor = self.bull_config["long_boost_factor"]
                if bull_score > 0.7:
                    boost_factor *= 1.1  # ì¶”ê°€ 10% ë¶€ìŠ¤íŠ¸
                
                boosted_score = phoenix95_score * boost_factor
                logging.info(f"ğŸ‚ ìƒìŠ¹ì¥ Long ë¶€ìŠ¤íŠ¸: {phoenix95_score:.3f} -> {boosted_score:.3f}")
                return min(boosted_score, 0.95)
            
            # ìƒìŠ¹ì¥ì—ì„œ Short ì‹ í˜¸ í˜ë„í‹° (ğŸ†• ëŒ€ì¹­ êµ¬ì¡°)
            elif signal.action.lower() in ["sell", "short"]:
                penalty_factor = self.bull_config["short_penalty_factor"]
                if bull_score > 0.6:
                    penalty_factor *= 0.95  # ì¶”ê°€ 5% ê°ì†Œ
                
                penalized_score = phoenix95_score * penalty_factor
                logging.warning(f"ğŸ‚ ìƒìŠ¹ì¥ Short í˜ë„í‹°: {phoenix95_score:.3f} -> {penalized_score:.3f}")
                return penalized_score
        
        # ê¸°ë³¸ê°’ ë°˜í™˜
        return phoenix95_score
    
    async def analyze_signal_complete(self, signal: SignalData) -> AnalysisResult:
        """ğŸ¯ ì™„ì „í•œ ì‹ í˜¸ ë¶„ì„ - ULTIMATE ë²„ì „ (Bull + Bear + HMM + Dynamic)"""
        analysis_start = time.time()
        
        try:
            # Pine Script ì‹ í˜¸ ì¶”ì 
            if signal.alpha_score is not None or signal.ml_signal is not None:
                self.performance_metrics["pine_script_signals"] += 1
            
            # 1. ìºì‹œ í™•ì¸
            cache_key = self._generate_cache_key(signal)
            cached_result = self._get_cached_analysis(cache_key)
            
            if cached_result:
                self.performance_metrics["cache_hits"] += 1
                cached_result.cache_hit = True
                return cached_result
            
            # 2. ì‹¤ì‹œê°„ ë°ì´í„° ê²€ì¦
            if self.phoenix_config["real_time_validation"]:
                validation_score = await self._validate_real_time_data(signal)
            else:
                validation_score = 0.8
            
            # 3. ê¸°ìˆ ì  ë¶„ì„
            technical_score, technical_details = await self._technical_analysis(signal)
            
            # 4. ì‹œì¥ ì¡°ê±´ ë¶„ì„
            market_score, market_conditions = await self._market_condition_analysis(signal)
            
            # 5. Pine Script IQE-V3 ë¶„ì„
            iqe_score, iqe_details = await self._pine_script_iqe_analysis(signal)
            
            # 6. ğŸ»ğŸ‚ ì‹œì¥ ì²´ì œ ê°ì§€ (í•µì‹¬!)
            market_regime = self.market_detector.detect_market_regime({
                "symbol": signal.symbol,
                "price": signal.price,
                "volume": signal.volume,
                "rsi": signal.rsi
            })
            regime_confidence = 0.8  # ì„ì‹œ ì‹ ë¢°ë„ (ì¶”í›„ HMMì—ì„œ ì‹¤ì œ ê³„ì‚°)
            
            # 7. ğŸ» í•˜ë½ì¥ ì „ìš© ë¶„ì„ (ê¸°ì¡´ + í–¥ìƒëœ ë²„ì „)
            bear_score, bear_details = await self._analyze_bear_market_signals(signal)
            enhanced_bear_score, enhanced_bear_details = await self._enhanced_bear_signals_lightweight(signal)
            
            # 8. ğŸ‚ ìƒìŠ¹ì¥ ì „ìš© ë¶„ì„ (NEW! + í–¥ìƒëœ ë²„ì „)
            bull_score, bull_details = await self.bull_analyzer.analyze_bull_signals(signal)
            enhanced_bull_score, enhanced_bull_details = await self._enhanced_bull_signals_lightweight(signal)
            
            # 9. ì‹œì¥ë³„ ì ìˆ˜ í†µí•© (ê¸°ì¡´ + í–¥ìƒëœ)
            combined_bear_score = (bear_score * 0.6 + enhanced_bear_score * 0.4)
            combined_bull_score = (bull_score * 0.6 + enhanced_bull_score * 0.4)
            
            # 10. Phoenix 95 ì ìˆ˜ ê³„ì‚° (ULTIMATE - Bull/Bear í¬í•¨)
            base_phoenix_score = await self._calculate_phoenix95_score_ultimate(
                signal, technical_score, market_score, validation_score, iqe_score,
                market_regime, combined_bear_score, combined_bull_score, regime_confidence
            )
            
            # 11. ğŸ”¥ ì‹œì¥ ì²´ì œì— ë”°ë¥¸ ì ìˆ˜ ì¡°ì • (ULTIMATE - ëŒ€ì¹­ êµ¬ì¡°)
            adjusted_phoenix_score = self._adjust_signal_for_market_regime(
                signal, base_phoenix_score, market_regime, combined_bear_score, combined_bull_score
            )
            
            # 12. ì‹œì¥ë³„ ì‹ í˜¸ ì¶”ì 
            if market_regime == "BEAR_MARKET" and combined_bear_score > 0.3:
                self.performance_metrics["bear_market_signals"] += 1
            elif market_regime == "BULL_MARKET" and combined_bull_score > 0.3:
                self.performance_metrics["bull_market_signals"] += 1
            
            # 13. í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° (ULTIMATE)
            quality_score = self._calculate_quality_score_ultimate(
                signal, adjusted_phoenix_score, technical_score, market_score, iqe_score,
                combined_bear_score, combined_bull_score, regime_confidence
            )
            
            # 14. ìµœì¢… ì‹ ë¢°ë„ ê³„ì‚°
            final_confidence = self._calculate_final_confidence(
                signal.confidence, adjusted_phoenix_score, quality_score
            )
            
            # 15. ğŸš€ Dynamic Position Sizing (ULTIMATE - Bull/Bear ê³ ë ¤)
            kelly_fraction, position_size = self._enhanced_kelly_dynamic_ultimate(
                final_confidence, technical_details, market_conditions, iqe_details, 
                market_regime, combined_bear_score, combined_bull_score
            )
            
            # 16. ë¦¬ìŠ¤í¬ í‰ê°€
            risk_level, risk_score = self._assess_risk(
                signal, final_confidence, kelly_fraction, market_conditions
            )
            
            # 17. ì‹¤í–‰ ê¶Œì¥ì‚¬í•­ ìƒì„±
            recommendation, execution_timing, urgency = self._generate_recommendation(
                final_confidence, risk_level, adjusted_phoenix_score, quality_score
            )
            
            # 18. ë¶„ì„ ì‹œê°„ ê³„ì‚°
            analysis_time = (time.time() - analysis_start) * 1000
            
            # 19. ê²°ê³¼ ê°ì²´ ìƒì„± (ULTIMATE)
            result = AnalysisResult(
                signal_id=signal.signal_id,
                symbol=signal.symbol,
                phoenix95_score=adjusted_phoenix_score,
                quality_score=quality_score,
                final_confidence=final_confidence,
                bear_market_score=combined_bear_score,  # ğŸ»
                bull_market_score=combined_bull_score,  # ğŸ‚ NEW!
                regime_confidence=regime_confidence,
                kelly_fraction=kelly_fraction,
                position_size=position_size,
                risk_level=risk_level,
                risk_score=risk_score,
                recommendation=recommendation,
                execution_timing=execution_timing,
                urgency=urgency,
                analysis_time_ms=analysis_time,
                cache_hit=False,
                model_used="Phoenix95_V5_ULTIMATE_Bull_Bear_HMM_Dynamic",
                technical_analysis=technical_details,
                market_conditions=market_conditions
            )
            
            # 20. ULTIMATE ë¶„ì„ ì •ë³´ ì¶”ê°€
            result.technical_analysis.update({
                "market_regime": market_regime,
                "regime_confidence": regime_confidence,
                "bear_market_score": combined_bear_score,
                "bear_details": bear_details,
                "enhanced_bear_details": enhanced_bear_details,
                "bull_market_score": combined_bull_score,      # ğŸ†• NEW!
                "bull_details": bull_details,                  # ğŸ†• NEW!
                "enhanced_bull_details": enhanced_bull_details, # ğŸ†• NEW!
                "regime_adjustment": adjusted_phoenix_score - base_phoenix_score,
                "hmm_available": HMM_AVAILABLE,
                "iqe_details": iqe_details,
                "dynamic_kelly_used": True,
                "ultimate_version": True  # ğŸ†• ULTIMATE ë²„ì „ ë§ˆí¬
            })
            
            # 21. ìºì‹œì— ì €ì¥
            self._cache_analysis(cache_key, result)
            
            # 22. ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            self._update_performance_metrics(result)
            
            # 23. í’ˆì§ˆ ì²´í¬ ë° ë¡œê¹… ê°•í™” (ULTIMATE)
            if final_confidence >= self.phoenix_config["confidence_threshold"]:
                iqe_info = f"IQE={iqe_score:.3f}" if iqe_score > 0 else "No-IQE"
                bear_info = f"ğŸ»={combined_bear_score:.3f}" if market_regime == "BEAR_MARKET" else ""
                bull_info = f"ğŸ‚={combined_bull_score:.3f}" if market_regime == "BULL_MARKET" else ""
                hmm_info = "ğŸ“ŠHMMâœ…" if HMM_AVAILABLE else "ğŸ“ŠHMMâŒ"
                
                logging.info(
                    f"ğŸ¯ ULTIMATE ê³ í’ˆì§ˆ ì‹ í˜¸: {signal.symbol} "
                    f"Phoenix95={adjusted_phoenix_score:.3f} "
                    f"Final={final_confidence:.3f} "
                    f"Kelly={kelly_fraction:.3f} "
                    f"Regime={market_regime} "
                    f"{iqe_info} {bear_info} {bull_info} {hmm_info} "
                    f"Time={analysis_time:.1f}ms"
                )
                
                # ì‹œì¥ë³„ ìƒì„¸ ë¡œê¹…
                if market_regime == "BEAR_MARKET":
                    logging.info(
                        f"ğŸ» í•˜ë½ì¥ ULTIMATE ì‹ í˜¸: {signal.symbol} {signal.action} "
                        f"Bear={combined_bear_score:.3f} Phoenix={adjusted_phoenix_score:.3f}"
                    )
                elif market_regime == "BULL_MARKET":
                    logging.info(
                        f"ğŸ‚ ìƒìŠ¹ì¥ ULTIMATE ì‹ í˜¸: {signal.symbol} {signal.action} "
                        f"Bull={combined_bull_score:.3f} Phoenix={adjusted_phoenix_score:.3f}"
                    )
                    
                # HMM ê°ì§€ ì¶”ì 
                if HMM_AVAILABLE and market_regime != "UNKNOWN":
                    self.performance_metrics["hmm_detections"] += 1
            else:
                logging.warning(
                    f"âš ï¸ ì €í’ˆì§ˆ ì‹ í˜¸: {signal.symbol} "
                    f"Final={final_confidence:.3f} < {self.phoenix_config['confidence_threshold']} "
                    f"Regime={market_regime}"
                )
            
            return result
            
        except Exception as e:
            logging.error(f"ğŸ§  ULTIMATE AI ë¶„ì„ ì‹¤íŒ¨: {signal.symbol} - {e}\n{traceback.format_exc()}")
            return self._create_fallback_result(signal, str(e), analysis_start)
    
    async def _calculate_phoenix95_score_ultimate(self, signal: SignalData, technical_score: float, 
                                            market_score: float, validation_score: float, iqe_score: float,
                                            market_regime: str, bear_score: float, bull_score: float,
                                            regime_confidence: float) -> float:
        """Phoenix 95 ì ìˆ˜ ê³„ì‚° ULTIMATE (Bull/Bear ê· í˜• í¬í•¨)"""
        # ê¸°ë³¸ ì‹ ë¢°ë„ ë¶€ìŠ¤íŒ…
        base_confidence = signal.confidence
        boosted_confidence = min(base_confidence * self.kelly_config["confidence_boost"], 1.0)
        
        # ê°€ì¤‘ í‰ê· ìœ¼ë¡œ Phoenix 95 ì ìˆ˜ ê³„ì‚° (ULTIMATE - Bull/Bear ê· í˜•)
        phoenix95_score = (
            boosted_confidence * 0.15 +
            technical_score * self.model_weights["technical_analysis"] +
            market_score * self.model_weights["market_sentiment"] +
            validation_score * 0.1 +
            iqe_score * self.model_weights["pine_script_iqe"] +
            regime_confidence * self.model_weights["hmm_regime_analysis"] +
            bear_score * self.model_weights["bear_market_signals"] +
            bull_score * self.model_weights["bull_market_signals"]     # ğŸ†• Bull ì ìˆ˜ ì¶”ê°€!
        )
        
        # ğŸ†• ì‹œì¥ë³„ íŠ¹ë³„ ë¶€ìŠ¤íŠ¸ (ëŒ€ì¹­ êµ¬ì¡°)
        if market_regime == "BULL_MARKET" and bull_score > 0.7:
            phoenix95_score *= 1.08  # 8% ìƒìŠ¹ì¥ ë¶€ìŠ¤íŠ¸
        elif market_regime == "BEAR_MARKET" and bear_score > 0.7:
            phoenix95_score *= 1.08  # 8% í•˜ë½ì¥ ë¶€ìŠ¤íŠ¸
        
        # IQE ë¶€ìŠ¤íŠ¸ (Pine Script ì‹ í˜¸ê°€ ìˆì„ ë•Œ)
        if iqe_score > 0.7:
            phoenix95_score *= 1.1  # 10% ë¶€ìŠ¤íŠ¸
        elif iqe_score > 0.5:
            phoenix95_score *= 1.05  # 5% ë¶€ìŠ¤íŠ¸
        
        # ì‹œê°„ëŒ€ë³„ ë³´ì •
        hour_boost = self._get_hour_boost(signal.timestamp.hour)
        phoenix95_score *= hour_boost
        
        # ì‹¬ë³¼ë³„ ë³´ì •
        symbol_boost = self._get_symbol_boost(signal.symbol)
        phoenix95_score *= symbol_boost
        
        return min(max(phoenix95_score, 0.0), 1.0)
    
    def _calculate_quality_score_ultimate(self, signal: SignalData, phoenix95_score: float, 
                                    technical_score: float, market_score: float, iqe_score: float,
                                    bear_score: float, bull_score: float, regime_confidence: float) -> float:
        """í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° ULTIMATE (Bull/Bear ê· í˜• í¬í•¨)"""
        # ì§€í‘œ ê°œìˆ˜ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤
        indicator_count = sum(1 for x in [signal.rsi, signal.macd, signal.volume] if x is not None)
        iqe_indicator_count = sum(1 for x in [signal.alpha_score, signal.z_score, signal.ml_signal] if x is not None)
        
        total_indicators = indicator_count + iqe_indicator_count
        indicator_bonus = min(total_indicators * 0.03, 0.2)
        
        # ì‹ ë¢°ë„ ì¼ê´€ì„± ì²´í¬
        confidence_consistency = 1.0 - abs(signal.confidence - phoenix95_score) * 0.5
        
        # ğŸ†• ìƒˆ ê¸°ëŠ¥ í’ˆì§ˆ ë³´ë„ˆìŠ¤ë“¤
        iqe_bonus = min(iqe_score * 0.08, 0.08) if iqe_score > 0.5 else 0
        hmm_bonus = min(regime_confidence * 0.05, 0.05) if regime_confidence > 0.7 else 0
        bear_bonus = min(bear_score * 0.06, 0.06) if bear_score > 0.5 else 0
        bull_bonus = min(bull_score * 0.06, 0.06) if bull_score > 0.5 else 0  # ğŸ†• Bull ë³´ë„ˆìŠ¤
        
        # ìµœì¢… í’ˆì§ˆ ì ìˆ˜ (ULTIMATE - ê· í˜•ì¡íŒ êµ¬ì¡°)
        quality_score = (
            phoenix95_score * 0.22 +     # ë¹„ì¤‘ ì¡°ì •
            technical_score * 0.18 +
            market_score * 0.13 +
            iqe_score * 0.12 +
            bear_score * 0.075 +         # ğŸ»
            bull_score * 0.075 +         # ğŸ‚ ì¶”ê°€!
            regime_confidence * 0.08 +
            confidence_consistency * 0.08 +
            indicator_bonus +
            iqe_bonus +
            hmm_bonus +
            bear_bonus +
            bull_bonus                   # ğŸ†• Bull ë³´ë„ˆìŠ¤ ì¶”ê°€
        )
        
        return min(max(quality_score, 0.0), 1.0)

    def _enhanced_kelly_dynamic_ultimate(self, confidence: float, technical_details: Dict, 
                              market_conditions: Dict, iqe_details: Dict = None, 
                              market_regime: str = "UNKNOWN", bear_score: float = 0.0, 
                              bull_score: float = 0.0) -> Tuple[float, float]:
        """ğŸš€ Dynamic Position Sizing ULTIMATE - Bull/Bear ëŒ€ì¹­ ê³ ë ¤"""
        try:
            # ê¸°ë³¸ Kelly ê³„ì‚°
            win_probability = confidence * self.kelly_config["win_rate_adjustment"]
            
            # IQE ìŠ¹ë¥  ë³´ì • (ê°„ë‹¨í•œ ê³±ì…ˆ)
            if iqe_details and iqe_details.get("overall_score", 0) > 0.8:
                win_probability *= 1.05  # 5% ìŠ¹ë¥  ë¶€ìŠ¤íŠ¸
            
            # ê¸°ë³¸ Kelly ë¶„ìˆ˜
            base_kelly = win_probability * self.kelly_config["max_kelly_fraction"]
            
            # ğŸ†• Dynamic ì‹œì¥ ì²´ì œë³„ ì¡°ì • (ULTIMATE - ëŒ€ì¹­ êµ¬ì¡°)
            regime_multiplier = 1.0
            
            if market_regime == "BEAR_MARKET":
                # Bear scoreê°€ ë†’ì„ìˆ˜ë¡ ë” ë³´ìˆ˜ì  ë˜ëŠ” ì ê·¹ì  ì¡°ì •
                if bear_score > 0.7:
                    regime_multiplier = 0.75  # ê³ í’ˆì§ˆ í•˜ë½ì¥ ì‹ í˜¸ì‹œ ëœ ë³´ìˆ˜ì 
                else:
                    regime_multiplier = 0.7   # ì¼ë°˜ í•˜ë½ì¥ 30% ì¶•ì†Œ
                adjustment_reason = f"Bear market (score={bear_score:.2f})"
                
            elif market_regime == "BULL_MARKET":
                # Bull scoreê°€ ë†’ì„ìˆ˜ë¡ ë” ì ê·¹ì  ì¡°ì • (ğŸ†• ëŒ€ì¹­ êµ¬ì¡°)
                if bull_score > 0.7:
                    regime_multiplier = 1.25  # ê³ í’ˆì§ˆ ìƒìŠ¹ì¥ ì‹ í˜¸ì‹œ ë” ì ê·¹ì 
                else:
                    regime_multiplier = 1.2   # ì¼ë°˜ ìƒìŠ¹ì¥ 20% í™•ëŒ€
                adjustment_reason = f"Bull market (score={bull_score:.2f})"
                
            elif market_regime == "SIDEWAYS":
                regime_multiplier = 0.9  # íš¡ë³´ì¥ 10% ì¶•ì†Œ (ì‹ ì¤‘í•¨)
                adjustment_reason = "Sideways market cautious"
            else:
                regime_multiplier = 0.85  # ë¶ˆí™•ì‹¤ì‹œ 15% ì¶•ì†Œ (ì•ˆì „)
                adjustment_reason = "Unknown regime safe"
            
            # Dynamic Kelly ì ìš©
            dynamic_kelly = base_kelly * regime_multiplier
            
            # ğŸ†• ì¶”ê°€ Dynamic ì¡°ì •ë“¤ (ê°„ë‹¨í•œ ì—°ì‚°ë§Œ)
            
            # ë³€ë™ì„± ì¡°ì • (ê¸°ì¡´ ë¡œì§ ìœ ì§€í•˜ë˜ ê°œì„ )
            volatility = market_conditions.get("volatility", {}).get("value", 0.3)
            if volatility > 0.6:
                dynamic_kelly *= 0.8  # ê³ ë³€ë™ì„±ì‹œ 20% ì¶•ì†Œ
            elif volatility < 0.2:
                dynamic_kelly *= 1.1  # ì €ë³€ë™ì„±ì‹œ 10% í™•ëŒ€
            
            # ê¸°ìˆ ì  ë¶„ì„ í’ˆì§ˆ ì¡°ì •
            tech_score = technical_details.get("overall_score", 0.5)
            if tech_score > 0.8:
                dynamic_kelly *= 1.05  # ê³ í’ˆì§ˆ ê¸°ìˆ ë¶„ì„ì‹œ 5% í™•ëŒ€
            elif tech_score < 0.4:
                dynamic_kelly *= 0.9   # ì €í’ˆì§ˆ ê¸°ìˆ ë¶„ì„ì‹œ 10% ì¶•ì†Œ
            
            # ğŸ†• Bull/Bear ì ìˆ˜ ê¸°ë°˜ ì¶”ê°€ ì¡°ì •
            max_signal_score = max(bear_score, bull_score)
            if max_signal_score > 0.8:
                dynamic_kelly *= 1.03  # ê°•í•œ ë°©í–¥ì„± ì‹ í˜¸ì‹œ 3% í™•ëŒ€
            elif max_signal_score < 0.3:
                dynamic_kelly *= 0.95  # ì•½í•œ ë°©í–¥ì„± ì‹ í˜¸ì‹œ 5% ì¶•ì†Œ
            
            # í•œê³„ê°’ ì ìš©
            dynamic_kelly = max(
                self.kelly_config["min_kelly_fraction"],
                min(dynamic_kelly, self.kelly_config["max_kelly_fraction"])
            )
            
            # í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            position_size = dynamic_kelly
            
            # Dynamic ì¡°ì • ì¶”ì 
            if abs(dynamic_kelly - base_kelly) > 0.001:
                self.performance_metrics["dynamic_kelly_adjustments"] += 1
            
            # ë¡œê¹… (ULTIMATE ìƒì„¸ ì •ë³´)
            logging.info(
                f"ğŸ¯ ULTIMATE Dynamic Kelly: Base={base_kelly:.4f} -> Dynamic={dynamic_kelly:.4f} "
                f"({adjustment_reason}, ğŸ»{bear_score:.2f} ğŸ‚{bull_score:.2f})"
            )
            
            return dynamic_kelly, position_size
            
        except Exception as e:
            logging.error(f"ULTIMATE Dynamic Kelly ê³„ì‚° ì˜¤ë¥˜: {e}")
            # ì•ˆì „í•œ ê¸°ë³¸ê°’ ë°˜í™˜
            safe_kelly = self.kelly_config["min_kelly_fraction"]
            return safe_kelly, safe_kelly
    
    async def _pine_script_iqe_analysis(self, signal: SignalData) -> Tuple[float, Dict]:
        """ğŸ†• Pine Script IQE-V3 ë¶„ì„"""
        iqe_details = {}
        scores = []
        
        # Alpha Score ë¶„ì„
        if signal.alpha_score is not None:
            alpha_normalized = max(0, min(1, (signal.alpha_score + 1) / 2))  # -1~1ì„ 0~1ë¡œ
            scores.append(alpha_normalized)
            iqe_details["alpha_score"] = {
                "value": signal.alpha_score,
                "normalized": alpha_normalized,
                "weight": 0.35
            }
        
        # Z-Score ë¶„ì„
        if signal.z_score is not None:
            # Z-Scoreë¥¼ ì‹ ë¢°ë„ë¡œ ë³€í™˜ (ì ˆëŒ“ê°’ì´ í´ìˆ˜ë¡ ê°•í•œ ì‹ í˜¸)
            z_confidence = min(1.0, abs(signal.z_score) / 3.0)  # 3-sigma ê¸°ì¤€
            scores.append(z_confidence)
            iqe_details["z_score"] = {
                "value": signal.z_score,
                "confidence": z_confidence,
                "weight": 0.25
            }
        
        # ML Signal ë¶„ì„
        if signal.ml_signal is not None:
            ml_normalized = max(0, min(1, abs(signal.ml_signal)))
            scores.append(ml_normalized)
            iqe_details["ml_signal"] = {
                "value": signal.ml_signal,
                "normalized": ml_normalized,
                "weight": 0.25
            }
        
        # ML Confidence ë¶„ì„
        if signal.ml_confidence:
            confidence_map = {
                "very_high": 0.95,
                "high": 0.85,
                "medium": 0.70,
                "low": 0.50,
                "very_low": 0.30
            }
            ml_conf_score = confidence_map.get(signal.ml_confidence.lower(), 0.60)
            scores.append(ml_conf_score)
            iqe_details["ml_confidence"] = {
                "level": signal.ml_confidence,
                "score": ml_conf_score,
                "weight": 0.15
            }
        
        # ì¢…í•© IQE ì ìˆ˜ ê³„ì‚°
        if scores:
            # ê°€ì¤‘ í‰ê·  (ë” ë§ì€ ì§€í‘œê°€ ìˆì„ìˆ˜ë¡ ì‹ ë¢°ë„ ì¦ê°€)
            base_score = np.mean(scores)
            indicator_bonus = min(0.1, len(scores) * 0.02)  # ì§€í‘œ ê°œìˆ˜ ë³´ë„ˆìŠ¤
            iqe_score = min(1.0, base_score + indicator_bonus)
            
            iqe_details["overall_score"] = iqe_score
            iqe_details["indicators_used"] = len(scores)
            iqe_details["indicator_bonus"] = indicator_bonus
            
            logging.info(f"ğŸ¯ IQE-V3 ë¶„ì„: {signal.symbol} Score={iqe_score:.3f} ({len(scores)}ê°œ ì§€í‘œ)")
        else:
            iqe_score = 0.0
            iqe_details["overall_score"] = 0.0
            iqe_details["indicators_used"] = 0
            iqe_details["note"] = "No Pine Script IQE indicators available"
        
        return iqe_score, iqe_details
    
    def _generate_cache_key(self, signal: SignalData) -> str:
        """ìºì‹œ í‚¤ ìƒì„± (Pine Script í•„ë“œ í¬í•¨)"""
        key_data = (f"{signal.symbol}_{signal.action}_{signal.price}_{signal.confidence}_"
                   f"{signal.timestamp.hour}_{signal.alpha_score}_{signal.ml_signal}")
        return hashlib.md5(key_data.encode()).hexdigest()
    
    def _get_cached_analysis(self, cache_key: str) -> Optional[AnalysisResult]:
        """ìºì‹œëœ ë¶„ì„ ê²°ê³¼ ì¡°íšŒ"""
        if cache_key not in self.analysis_cache:
            return None
        
        cached_data, cached_time = self.analysis_cache[cache_key]
        cache_duration = self.phoenix_config["cache_duration"]
        
        if time.time() - cached_time > cache_duration:
            del self.analysis_cache[cache_key]
            return None
        
        return cached_data
    
    def _cache_analysis(self, cache_key: str, result: AnalysisResult):
        """ë¶„ì„ ê²°ê³¼ ìºì‹±"""
        self.analysis_cache[cache_key] = (result, time.time())
        
        # ìºì‹œ í¬ê¸° ì œí•œ
        if len(self.analysis_cache) > 1000:
            oldest_key = min(self.analysis_cache.keys(), 
                           key=lambda k: self.analysis_cache[k][1])
            del self.analysis_cache[oldest_key]
    
    async def _validate_real_time_data(self, signal: SignalData) -> float:
        """ì‹¤ì‹œê°„ ë°ì´í„° ê²€ì¦"""
        try:
            # ì‹¤ì œ ê°€ê²© ì¡°íšŒ ì‹œë®¬ë ˆì´ì…˜
            current_price = signal.price * (1 + np.random.uniform(-0.01, 0.01))
            price_diff = abs(signal.price - current_price) / current_price
            
            if price_diff < 0.005:  # 0.5% ì´ë‚´
                return 0.95
            elif price_diff < 0.01:  # 1% ì´ë‚´
                return 0.85
            elif price_diff < 0.02:  # 2% ì´ë‚´
                return 0.70
            else:
                return 0.50
                
        except Exception as e:
            logging.warning(f"ì‹¤ì‹œê°„ ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨: {e}")
            return 0.70
    
    async def _technical_analysis(self, signal: SignalData) -> Tuple[float, Dict]:
        """ê¸°ìˆ ì  ë¶„ì„"""
        technical_scores = []
        details = {}
        
        # RSI ë¶„ì„
        if signal.rsi is not None:
            rsi_score = self._analyze_rsi(signal.rsi, signal.action)
            technical_scores.append(rsi_score)
            details["rsi"] = {"value": signal.rsi, "score": rsi_score}
        
        # MACD ë¶„ì„
        if signal.macd is not None:
            macd_score = self._analyze_macd(signal.macd, signal.action)
            technical_scores.append(macd_score)
            details["macd"] = {"value": signal.macd, "score": macd_score}
        
        # ë³¼ë¦°ì € ë°´ë“œ ë¶„ì„
        if signal.bollinger_upper and signal.bollinger_lower:
            bb_score = self._analyze_bollinger_bands(
                signal.price, signal.bollinger_upper, signal.bollinger_lower, signal.action
            )
            technical_scores.append(bb_score)
            details["bollinger"] = {"score": bb_score}
        
        # ê±°ë˜ëŸ‰ ë¶„ì„
        if signal.volume:
            volume_score = self._analyze_volume(signal.volume)
            technical_scores.append(volume_score)
            details["volume"] = {"value": signal.volume, "score": volume_score}
        
        # ì¢…í•© ê¸°ìˆ ì  ì ìˆ˜
        if technical_scores:
            technical_score = np.mean(technical_scores)
        else:
            technical_score = signal.confidence * 0.8
        
        details["overall_score"] = technical_score
        details["indicators_count"] = len(technical_scores)
        
        return technical_score, details
    
    def _analyze_rsi(self, rsi: float, action: str) -> float:
        """RSI ë¶„ì„"""
        if action in ['buy', 'long']:
            if rsi <= 30:
                return 0.9
            elif rsi <= 40:
                return 0.7
            elif rsi <= 50:
                return 0.6
            elif rsi <= 60:
                return 0.4
            else:
                return 0.2
        else:  # sell, short
            if rsi >= 70:
                return 0.9
            elif rsi >= 60:
                return 0.7
            elif rsi >= 50:
                return 0.6
            elif rsi >= 40:
                return 0.4
            else:
                return 0.2
    
    def _analyze_macd(self, macd: float, action: str) -> float:
        """MACD ë¶„ì„"""
        if action in ['buy', 'long']:
            if macd > 0.01:
                return 0.8
            elif macd > 0:
                return 0.6
            elif macd > -0.005:
                return 0.4
            else:
                return 0.3
        else:  # sell, short
            if macd < -0.01:
                return 0.8
            elif macd < 0:
                return 0.6
            elif macd < 0.005:
                return 0.4
            else:
                return 0.3
    
    def _analyze_bollinger_bands(self, price: float, upper: float, lower: float, action: str) -> float:
        """ë³¼ë¦°ì € ë°´ë“œ ë¶„ì„"""
        bb_position = (price - lower) / (upper - lower) if upper != lower else 0.5
        
        if action in ['buy', 'long']:
            if bb_position <= 0.2:
                return 0.8
            elif bb_position <= 0.4:
                return 0.6
            elif bb_position <= 0.6:
                return 0.5
            else:
                return 0.3
        else:  # sell, short
            if bb_position >= 0.8:
                return 0.8
            elif bb_position >= 0.6:
                return 0.6
            elif bb_position >= 0.4:
                return 0.5
            else:
                return 0.3
    
    def _analyze_volume(self, volume: float) -> float:
        """ê±°ë˜ëŸ‰ ë¶„ì„"""
        # ê±°ë˜ëŸ‰ ì •ê·œí™” (ì‹¬ë³¼ë³„ í‰ê·  ê±°ë˜ëŸ‰ ëŒ€ë¹„)
        if volume > 10000000:
            return 0.9
        elif volume > 5000000:
            return 0.7
        elif volume > 1000000:
            return 0.6
        elif volume > 100000:
            return 0.4
        else:
            return 0.3
    
    async def _market_condition_analysis(self, signal: SignalData) -> Tuple[float, Dict]:
        """ì‹œì¥ ì¡°ê±´ ë¶„ì„"""
        conditions = {}
        scores = []
        
        # ì‹œê°„ëŒ€ ë¶„ì„
        hour = signal.timestamp.hour
        time_score = self._analyze_trading_hours(hour)
        scores.append(time_score)
        conditions["trading_hours"] = {"hour": hour, "score": time_score}
        
        # ìš”ì¼ ë¶„ì„
        weekday = signal.timestamp.weekday()
        weekday_score = self._analyze_weekday(weekday)
        scores.append(weekday_score)
        conditions["weekday"] = {"day": weekday, "score": weekday_score}
        
        # ë³€ë™ì„± ë¶„ì„ (ì‹œë®¬ë ˆì´ì…˜)
        volatility = np.random.uniform(0.1, 0.8)
        volatility_score = self._analyze_volatility(volatility)
        scores.append(volatility_score)
        conditions["volatility"] = {"value": volatility, "score": volatility_score}
        
        # ì‹œì¥ ì„¼í‹°ë©˜íŠ¸ (ì‹œë®¬ë ˆì´ì…˜)
        sentiment = np.random.uniform(0.2, 0.9)
        sentiment_score = sentiment
        scores.append(sentiment_score)
        conditions["sentiment"] = {"value": sentiment, "score": sentiment_score}
        
        market_score = np.mean(scores)
        conditions["overall_score"] = market_score
        
        return market_score, conditions
    
    def _analyze_trading_hours(self, hour: int) -> float:
        """ê±°ë˜ ì‹œê°„ëŒ€ ë¶„ì„"""
        if 8 <= hour <= 12:     # ì•„ì‹œì•„ ì˜¤ì „
            return 0.8
        elif 13 <= hour <= 17:  # ìœ ëŸ½ ì‹œê°„
            return 0.9
        elif 21 <= hour <= 1:   # ë¯¸êµ­ ì‹œê°„
            return 0.85
        elif 2 <= hour <= 6:    # ì €ì¡°í•œ ì‹œê°„
            return 0.3
        else:
            return 0.6
    
    def _analyze_weekday(self, weekday: int) -> float:
        """ìš”ì¼ ë¶„ì„"""
        weekday_scores = [0.8, 0.9, 0.9, 0.85, 0.7, 0.4, 0.3]  # ì›”~ì¼
        return weekday_scores[weekday]
    
    def _analyze_volatility(self, volatility: float) -> float:
        """ë³€ë™ì„± ë¶„ì„"""
        if 0.2 <= volatility <= 0.5:
            return 0.9  # ì ì • ë³€ë™ì„±
        elif 0.1 <= volatility < 0.2:
            return 0.6  # ë‚®ì€ ë³€ë™ì„±
        elif 0.5 < volatility <= 0.7:
            return 0.7  # ë†’ì€ ë³€ë™ì„±
        else:
            return 0.4  # ê·¹ë‹¨ì  ë³€ë™ì„±
    
    def _get_hour_boost(self, hour: int) -> float:
        """ì‹œê°„ëŒ€ë³„ ë¶€ìŠ¤íŠ¸"""
        if 8 <= hour <= 12:
            return 1.05
        elif 13 <= hour <= 17:
            return 1.1
        elif 21 <= hour <= 1:
            return 1.08
        else:
            return 1.0
    
    def _get_symbol_boost(self, symbol: str) -> float:
        """ì‹¬ë³¼ë³„ ë¶€ìŠ¤íŠ¸"""
        major_symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]
        if symbol in major_symbols:
            return 1.05
        else:
            return 1.0
    
    def _calculate_final_confidence(self, original_confidence: float, 
                                  phoenix95_score: float, quality_score: float) -> float:
        """ìµœì¢… ì‹ ë¢°ë„ ê³„ì‚°"""
        # ê°€ì¤‘ í‰ê· 
        final_confidence = (
            original_confidence * 0.2 +
            phoenix95_score * 0.5 +
            quality_score * 0.3
        )
        
        return min(max(final_confidence, 0.0), 1.0)
    
    def _assess_risk(self, signal: SignalData, confidence: float, kelly_fraction: float, 
                    market_conditions: Dict) -> Tuple[str, float]:
        """ë¦¬ìŠ¤í¬ í‰ê°€"""
        risk_factors = []
        
        # ì‹ ë¢°ë„ ë¦¬ìŠ¤í¬
        if confidence < 0.6:
            risk_factors.append(0.3)
        elif confidence < 0.8:
            risk_factors.append(0.1)
        
        # Kelly í¬ì§€ì…˜ ë¦¬ìŠ¤í¬
        if kelly_fraction > 0.15:
            risk_factors.append(0.2)
        elif kelly_fraction > 0.1:
            risk_factors.append(0.1)
        
        # ì‹œì¥ ì¡°ê±´ ë¦¬ìŠ¤í¬
        market_score = market_conditions.get("overall_score", 0.5)
        if market_score < 0.5:
            risk_factors.append(0.2)
        elif market_score < 0.7:
            risk_factors.append(0.1)
        
        # ë³€ë™ì„± ë¦¬ìŠ¤í¬
        volatility = market_conditions.get("volatility", {}).get("value", 0.3)
        if volatility > 0.6:
            risk_factors.append(0.25)
        elif volatility > 0.4:
            risk_factors.append(0.1)
        
        # ì¢…í•© ë¦¬ìŠ¤í¬ ì ìˆ˜
        risk_score = sum(risk_factors)
        
        # ë¦¬ìŠ¤í¬ ë ˆë²¨ ê²°ì •
        if risk_score <= 0.2:
            risk_level = "LOW"
        elif risk_score <= 0.4:
            risk_level = "MEDIUM"
        elif risk_score <= 0.6:
            risk_level = "HIGH"
        else:
            risk_level = "VERY_HIGH"
        
        return risk_level, risk_score
    
    def _generate_recommendation(self, confidence: float, risk_level: str, 
                               phoenix95_score: float, quality_score: float) -> Tuple[str, str, int]:
        """ì‹¤í–‰ ê¶Œì¥ì‚¬í•­ ìƒì„±"""
        # ì¶”ì²œ ê²°ì •
        if (confidence >= self.phoenix_config["confidence_threshold"] and 
            risk_level in ["LOW", "MEDIUM"] and 
            phoenix95_score >= 0.75):
            recommendation = "STRONG_BUY" if phoenix95_score >= 0.9 else "BUY"
            execution_timing = "IMMEDIATE"
            urgency = min(10, int(confidence * 10))
        elif (confidence >= 0.7 and 
              risk_level in ["LOW", "MEDIUM"] and 
              quality_score >= self.phoenix_config["quality_threshold"]):
            recommendation = "WEAK_BUY"
            execution_timing = "CAREFUL"
            urgency = min(7, int(confidence * 8))
        elif confidence >= 0.6 and risk_level != "VERY_HIGH":
            recommendation = "HOLD"
            execution_timing = "MONITOR"
            urgency = min(5, int(confidence * 6))
        else:
            recommendation = "REJECT"
            execution_timing = "HOLD"
            urgency = 1
        
        return recommendation, execution_timing, urgency
    
    def _create_fallback_result(self, signal: SignalData, error: str, start_time: float) -> AnalysisResult:
        """ì˜¤ë¥˜ì‹œ ëŒ€ì²´ ê²°ê³¼ ìƒì„± (ULTIMATE)"""
        analysis_time = (time.time() - start_time) * 1000
        
        return AnalysisResult(
            signal_id=signal.signal_id,
            symbol=signal.symbol,
            phoenix95_score=0.0,
            quality_score=0.0,
            final_confidence=0.0,
            bear_market_score=0.0,       # ğŸ»
            bull_market_score=0.0,       # ğŸ‚
            regime_confidence=0.0,
            kelly_fraction=0.01,
            position_size=0.01,
            risk_level="VERY_HIGH",
            risk_score=1.0,
            recommendation="REJECT",
            execution_timing="HOLD",
            urgency=0,
            analysis_time_ms=analysis_time,
            cache_hit=False,
            model_used="FALLBACK",
            technical_analysis={"error": error},
            market_conditions={"error": error}
        )
    
    def _update_performance_metrics(self, result: AnalysisResult):
        """ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸"""
        self.performance_metrics["total_analyses"] += 1
        
        if result.recommendation != "REJECT":
            self.performance_metrics["successful_analyses"] += 1
        
        # ì´ë™ í‰ê· ìœ¼ë¡œ ë¶„ì„ ì‹œê°„ ì—…ë°ì´íŠ¸
        total = self.performance_metrics["total_analyses"]
        current_avg = self.performance_metrics["avg_analysis_time"]
        new_avg = (current_avg * (total - 1) + result.analysis_time_ms) / total
        self.performance_metrics["avg_analysis_time"] = new_avg
    
    def get_performance_summary(self) -> Dict:
        """ì„±ëŠ¥ ìš”ì•½ ì¡°íšŒ (ULTIMATE - Bull/Bear í¬í•¨)"""
        total = self.performance_metrics["total_analyses"]
        success_rate = (
            self.performance_metrics["successful_analyses"] / total * 100 
            if total > 0 else 0
        )
        cache_hit_rate = (
            self.performance_metrics["cache_hits"] / total * 100 
            if total > 0 else 0
        )
        pine_script_rate = (
            self.performance_metrics["pine_script_signals"] / total * 100 
            if total > 0 else 0
        )
        bear_market_rate = (
            self.performance_metrics["bear_market_signals"] / total * 100 
            if total > 0 else 0
        )
        bull_market_rate = (  # ğŸ†• Bull ì‹ í˜¸ìœ¨
            self.performance_metrics["bull_market_signals"] / total * 100 
            if total > 0 else 0
        )
        # ğŸ†• ìƒˆë¡œìš´ ë©”íŠ¸ë¦­ë“¤
        hmm_detection_rate = (
            self.performance_metrics["hmm_detections"] / total * 100 
            if total > 0 else 0
        )
        enhanced_bear_rate = (
            self.performance_metrics["enhanced_bear_signals"] / total * 100 
            if total > 0 else 0
        )
        enhanced_bull_rate = (  # ğŸ†• í–¥ìƒëœ Bull ì‹ í˜¸ìœ¨
            self.performance_metrics["enhanced_bull_signals"] / total * 100 
            if total > 0 else 0
        )
        dynamic_kelly_rate = (
            self.performance_metrics["dynamic_kelly_adjustments"] / total * 100 
            if total > 0 else 0
        )
        
        return {
            "total_analyses": total,
            "success_rate": round(success_rate, 2),
            "cache_hit_rate": round(cache_hit_rate, 2),
            "pine_script_rate": round(pine_script_rate, 2),
            "bear_market_rate": round(bear_market_rate, 2),
            "bull_market_rate": round(bull_market_rate, 2),        # ğŸ†• Bull ì‹ í˜¸ìœ¨
            "hmm_detection_rate": round(hmm_detection_rate, 2),
            "enhanced_bear_rate": round(enhanced_bear_rate, 2),
            "enhanced_bull_rate": round(enhanced_bull_rate, 2),    # ğŸ†• í–¥ìƒëœ Bull ì‹ í˜¸ìœ¨
            "dynamic_kelly_rate": round(dynamic_kelly_rate, 2),
            "avg_analysis_time_ms": round(self.performance_metrics["avg_analysis_time"], 2),
            "cache_size": len(self.analysis_cache),
            "hmm_available": HMM_AVAILABLE,
            "ultimate_version": True  # ğŸ†• ULTIMATE ë²„ì „ ë§ˆí¬
        }

# =============================================================================
# ğŸ“¡ ë©”ì‹œì§€ í & ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ (ê¸°ì¡´ê³¼ ë™ì¼)
# =============================================================================

class MessageQueuePublisher:
    """RabbitMQ ë©”ì‹œì§€ ë°œí–‰ì"""
    
    def __init__(self, config: BrainServiceConfig):
        self.config = config.RABBITMQ_CONFIG
        self.connection = None
        self.channel = None
        self.connected = False
    
    async def connect(self):
        """RabbitMQ ì—°ê²°"""
        try:
            connection_params = aio_pika.ConnectionParameters(
                host=self.config["host"],
                port=self.config["port"],
                login=self.config["username"],
                password=self.config["password"],
                virtual_host=self.config["virtual_host"]
            )
            
            self.connection = await aio_pika.connect_robust(
                host=self.config["host"],
                port=self.config["port"],
                login=self.config["username"],
                password=self.config["password"],
                virtualhost=self.config["virtual_host"]
            )
            
            self.channel = await self.connection.channel()
            
            # Exchange ìƒì„±
            self.exchange = await self.channel.declare_exchange(
                self.config["exchange"],
                aio_pika.ExchangeType.DIRECT,
                durable=self.config["durable"]
            )
            
            # Queue ìƒì„±
            self.queue = await self.channel.declare_queue(
                self.config["queue"],
                durable=self.config["durable"]
            )
            
            await self.queue.bind(self.exchange, self.config["routing_key"])
            
            self.connected = True
            logging.info("ğŸ° RabbitMQ ì—°ê²° ì„±ê³µ")
            
        except Exception as e:
            logging.error(f"ğŸ° RabbitMQ ì—°ê²° ì‹¤íŒ¨: {e}")
            self.connected = False
    
    async def publish_analysis_result(self, signal: SignalData, result: AnalysisResult):
        """ë¶„ì„ ê²°ê³¼ ë°œí–‰"""
        if not self.connected:
            await self.connect()
        
        if not self.connected:
            logging.warning("ğŸ° RabbitMQ ì—°ê²° ì‹¤íŒ¨ - ë©”ì‹œì§€ ë°œí–‰ ë¶ˆê°€")
            return
        
        try:
            message_data = {
                "signal": signal.to_dict(),
                "analysis": result.to_dict(),
                "timestamp": time.time(),
                "service": "BRAIN_ULTIMATE"
            }
            
            message = aio_pika.Message(
                json.dumps(message_data).encode(),
                content_type="application/json",
                delivery_mode=aio_pika.DeliveryMode.PERSISTENT
            )
            
            await self.exchange.publish(
                message,
                routing_key=self.config["routing_key"]
            )
            
            logging.info(f"ğŸ“¤ ULTIMATE ë¶„ì„ ê²°ê³¼ ë°œí–‰: {signal.symbol} -> {result.recommendation}")
            
        except Exception as e:
            logging.error(f"ğŸ“¤ ë©”ì‹œì§€ ë°œí–‰ ì‹¤íŒ¨: {e}")
    
    async def disconnect(self):
        """ì—°ê²° ì¢…ë£Œ"""
        if self.connection:
            await self.connection.close()
            self.connected = False
            logging.info("ğŸ° RabbitMQ ì—°ê²° ì¢…ë£Œ")

class RedisStreamPublisher:
    """Redis Streams ë°œí–‰ì"""
    
    def __init__(self, config: BrainServiceConfig):
        self.config = config.REDIS_CONFIG
        self.redis = None
        self.connected = False
    
    async def connect(self):
        """Redis ì—°ê²°"""
        try:
            self.redis = await aioredis.from_url(
                f"redis://{self.config['host']}:{self.config['port']}/{self.config['db']}"
            )
            
            # ìŠ¤íŠ¸ë¦¼ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ìƒì„±
            try:
                await self.redis.xgroup_create(
                    self.config["stream_name"],
                    self.config["consumer_group"],
                    id="0",
                    mkstream=True
                )
            except Exception:
                pass  # ê·¸ë£¹ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš°
            
            self.connected = True
            logging.info("ğŸ”´ Redis Streams ì—°ê²° ì„±ê³µ")
            
        except Exception as e:
            logging.error(f"ğŸ”´ Redis Streams ì—°ê²° ì‹¤íŒ¨: {e}")
            self.connected = False
    
    async def publish_stream_data(self, signal: SignalData, result: AnalysisResult):
        """ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë°œí–‰ (ULTIMATE)"""
        if not self.connected:
            await self.connect()
        
        if not self.connected:
            logging.warning("ğŸ”´ Redis Streams ì—°ê²° ì‹¤íŒ¨ - ìŠ¤íŠ¸ë¦¼ ë°œí–‰ ë¶ˆê°€")
            return
        
        try:
            stream_data = {
                "signal_id": signal.signal_id,
                "symbol": signal.symbol,
                "action": signal.action,
                "price": str(signal.price),
                "phoenix95_score": str(result.phoenix95_score),
                "final_confidence": str(result.final_confidence),
                "recommendation": result.recommendation,
                "kelly_fraction": str(result.kelly_fraction),
                "risk_level": result.risk_level,
                "bear_market_score": str(result.bear_market_score),  # ğŸ»
                "bull_market_score": str(result.bull_market_score),  # ğŸ‚
                "regime_confidence": str(result.regime_confidence),
                "timestamp": str(time.time()),
                "service": "BRAIN_ULTIMATE",
                "pine_script": "true" if signal.alpha_score is not None else "false",
                "market_regime": result.technical_analysis.get("market_regime", "UNKNOWN"),
                "ultimate_version": "true"  # ğŸ†• ULTIMATE ë§ˆí¬
            }
            
            message_id = await self.redis.xadd(
                self.config["stream_name"],
                stream_data,
                maxlen=self.config["max_len"]
            )
            
            logging.info(f"ğŸŒŠ ULTIMATE ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë°œí–‰: {signal.symbol} ID={message_id}")
            
        except Exception as e:
            logging.error(f"ğŸŒŠ ìŠ¤íŠ¸ë¦¼ ë°œí–‰ ì‹¤íŒ¨: {e}")
    
    async def disconnect(self):
        """ì—°ê²° ì¢…ë£Œ"""
        if self.redis:
            await self.redis.close()
            self.connected = False
            logging.info("ğŸ”´ Redis Streams ì—°ê²° ì¢…ë£Œ")

# =============================================================================
# ğŸ§  BRAIN ì„œë¹„ìŠ¤ ë©”ì¸ í´ë˜ìŠ¤ ULTIMATE
# =============================================================================

class BrainService:
    """ğŸ§  BRAIN ì„œë¹„ìŠ¤ ULTIMATE - Phoenix 95 + Pine Script + ğŸ»ğŸ‚ Bull/Bear + ğŸ“Š HMM + âš¡ Dynamic"""
    
    def __init__(self):
        self.config = BrainServiceConfig()
        self.app = FastAPI(
            title="ğŸ§  BRAIN Service ULTIMATE - Phoenix 95 + ğŸ»ğŸ‚ Bull/Bear + ğŸ“Š HMM",
            description="Phoenix 95 Signal Intelligence Engine + Pine Script IQE-V3 + Bull/Bear Market ê· í˜• íŠ¹í™” (í¬íŠ¸: 8100)",
            version=self.config.SERVICE_VERSION
        )
        
        # CORS ì„¤ì •
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        # í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™”
        self.ai_engine = Phoenix95AIEngine(self.config)
        self.mq_publisher = MessageQueuePublisher(self.config)
        self.stream_publisher = RedisStreamPublisher(self.config)
        
        # ì„œë¹„ìŠ¤ ìƒíƒœ (ULTIMATE)
        self.service_stats = {
            "start_time": time.time(),
            "total_requests": 0,
            "successful_analyses": 0,
            "failed_analyses": 0,
            "webhook_requests": 0,
            "pine_script_signals": 0,
            "bear_market_signals": 0,      # ğŸ» í•˜ë½ì¥ ì‹ í˜¸
            "bull_market_signals": 0,      # ğŸ‚ ìƒìŠ¹ì¥ ì‹ í˜¸ (NEW!)
            "active_connections": 0
        }
        
        # ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬
        self.background_tasks = []
        
        # ë¼ìš°íŠ¸ ì„¤ì •
        self._setup_routes()
        
        logging.info(f"ğŸ§  BRAIN ì„œë¹„ìŠ¤ ULTIMATE ì´ˆê¸°í™” ì™„ë£Œ (í¬íŠ¸: {self.config.SERVICE_PORT}) + Pine + ğŸ»ğŸ‚ Bull/Bear + ğŸ“Š HMM + âš¡ Dynamic")
    
    def _setup_routes(self):
        """ë¼ìš°íŠ¸ ì„¤ì • (ULTIMATE)"""
        
        @self.app.get("/")
        async def root():
            return HTMLResponse(self._generate_dashboard_html())
        
        @self.app.get("/health")
        async def health_check():
            """í—¬ìŠ¤ì²´í¬ (ULTIMATE)"""
            uptime = time.time() - self.service_stats["start_time"]
            
            return {
                "service": "BRAIN_ULTIMATE",
                "status": "healthy",
                "version": self.config.SERVICE_VERSION,
                "uptime_seconds": round(uptime, 2),
                "total_requests": self.service_stats["total_requests"],
                "webhook_requests": self.service_stats["webhook_requests"],
                "pine_script_signals": self.service_stats["pine_script_signals"],
                "bear_market_signals": self.service_stats["bear_market_signals"],
                "bull_market_signals": self.service_stats["bull_market_signals"],  # ğŸ†•
                "ai_engine_ready": True,
                "rabbitmq_connected": self.mq_publisher.connected,
                "redis_connected": self.stream_publisher.connected,
                "performance": self.ai_engine.get_performance_summary(),
                "ultimate_features": {
                    "bull_bear_analysis": True,
                    "hmm_regime_detection": HMM_AVAILABLE,
                    "dynamic_position_sizing": True,
                    "pine_script_iqe": True
                },
                "timestamp": time.time()
            }
        
        @self.app.post("/analyze")
        async def analyze_signal(request: SignalRequest, background_tasks: BackgroundTasks):
            """ğŸ¯ ì‹ í˜¸ ë¶„ì„ ë©”ì¸ ì—”ë“œí¬ì¸íŠ¸ (ULTIMATE)"""
            try:
                self.service_stats["total_requests"] += 1
                analysis_start = time.time()
                
                # SignalData ê°ì²´ ìƒì„±
                signal = SignalData(
                    signal_id=f"BRAIN_ULTIMATE_{int(time.time() * 1000)}",
                    symbol=request.symbol,
                    action=request.action,
                    price=request.price,
                    confidence=request.confidence,
                    timestamp=datetime.utcnow(),
                    rsi=request.rsi,
                    macd=request.macd,
                    volume=request.volume,
                    alpha_score=request.alpha_score,
                    z_score=request.z_score,
                    ml_signal=request.ml_signal,
                    ml_confidence=request.ml_confidence,
                    strategy=request.strategy,
                    timeframe=request.timeframe,
                    source="API"
                )
                
                # Pine Script ì‹ í˜¸ ì¶”ì 
                if any([signal.alpha_score, signal.z_score, signal.ml_signal]):
                    self.service_stats["pine_script_signals"] += 1
                
                # AI ë¶„ì„ ì‹¤í–‰ (ULTIMATE)
                analysis_result = await self.ai_engine.analyze_signal_complete(signal)
                
                # ğŸ»ğŸ‚ ì‹œì¥ë³„ ì‹ í˜¸ ì¶”ì 
                market_regime = analysis_result.technical_analysis.get("market_regime", "UNKNOWN")
                if market_regime == "BEAR_MARKET" and analysis_result.bear_market_score > 0.3:
                    self.service_stats["bear_market_signals"] += 1
                elif market_regime == "BULL_MARKET" and analysis_result.bull_market_score > 0.3:
                    self.service_stats["bull_market_signals"] += 1
                
                # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë©”ì‹œì§€ ë°œí–‰
                background_tasks.add_task(self._publish_results, signal, analysis_result)
                
                # ì„±ê³µ í†µê³„ ì—…ë°ì´íŠ¸
                if analysis_result.recommendation != "REJECT":
                    self.service_stats["successful_analyses"] += 1
                else:
                    self.service_stats["failed_analyses"] += 1
                
                # ì‘ë‹µ ìƒì„± (ULTIMATE)
                processing_time = (time.time() - analysis_start) * 1000
                
                response = {
                    "status": "success",
                    "signal_id": signal.signal_id,
                    "symbol": signal.symbol,
                    "analysis": {
                        "phoenix95_score": analysis_result.phoenix95_score,
                        "quality_score": analysis_result.quality_score,
                        "final_confidence": analysis_result.final_confidence,
                        "bear_market_score": analysis_result.bear_market_score,  # ğŸ»
                        "bull_market_score": analysis_result.bull_market_score,  # ğŸ‚
                        "regime_confidence": analysis_result.regime_confidence,
                        "recommendation": analysis_result.recommendation,
                        "execution_timing": analysis_result.execution_timing,
                        "urgency": analysis_result.urgency,
                        "risk_level": analysis_result.risk_level,
                        "risk_score": analysis_result.risk_score,
                        "market_regime": market_regime
                    },
                    "position_sizing": {
                        "kelly_fraction": analysis_result.kelly_fraction,
                        "position_size": analysis_result.position_size
                    },
                    "performance": {
                        "analysis_time_ms": analysis_result.analysis_time_ms,
                        "processing_time_ms": round(processing_time, 2),
                        "cache_hit": analysis_result.cache_hit,
                        "model_used": analysis_result.model_used
                    },
                    "service_info": {
                        "service": "BRAIN_ULTIMATE",
                        "version": self.config.SERVICE_VERSION,
                        "ultimate_features": True,
                        "timestamp": time.time()
                    }
                }
                
                # ê³ í’ˆì§ˆ ì‹ í˜¸ ë¡œê¹… (ULTIMATE)
                if analysis_result.final_confidence >= self.config.PHOENIX_95_CONFIG["confidence_threshold"]:
                    logging.info(
                        f"ğŸ¯ ULTIMATE ê³ í’ˆì§ˆ ì‹ í˜¸: {signal.symbol} "
                        f"Confidence={analysis_result.final_confidence:.3f} "
                        f"Recommendation={analysis_result.recommendation} "
                        f"Regime={market_regime} "
                        f"ğŸ»{analysis_result.bear_market_score:.3f} "
                        f"ğŸ‚{analysis_result.bull_market_score:.3f}"
                    )
                
                return response
                
            except Exception as e:
                self.service_stats["failed_analyses"] += 1
                logging.error(f"ğŸ§  ULTIMATE ë¶„ì„ ìš”ì²­ ì‹¤íŒ¨: {e}\n{traceback.format_exc()}")
                
                raise HTTPException(
                    status_code=500,
                    detail={
                        "error": "ULTIMATE ë¶„ì„ ì‹¤í–‰ ì‹¤íŒ¨",
                        "message": str(e),
                        "service": "BRAIN_ULTIMATE"
                    }
                )
        
        @self.app.post("/webhook")
        async def tradingview_webhook(request: Request, background_tasks: BackgroundTasks):
            """ğŸ¯ TradingView Pine Script ì›¹í›… ì—”ë“œí¬ì¸íŠ¸ (ULTIMATE - Bull/Bear ìµœì í™”)"""
            try:
                self.service_stats["webhook_requests"] += 1
                webhook_start = time.time()
                
                # ì›¹í›… ë°ì´í„° íŒŒì‹±
                webhook_data = await request.json()
                logging.info(f"ğŸ“¥ TradingView ULTIMATE ì›¹í›… ìˆ˜ì‹ : {webhook_data}")
                
                # Pine Script ì‹ í˜¸ íŒŒì‹± (ULTIMATE ìµœì í™”)
                signal = await self._parse_tradingview_signal_ultimate(webhook_data)
                
                if not signal:
                    logging.warning("âš ï¸ Pine Script ULTIMATE ì‹ í˜¸ íŒŒì‹± ì‹¤íŒ¨")
                    return JSONResponse(
                        status_code=400,
                        content={
                            "status": "error",
                            "message": "Invalid Pine Script ULTIMATE signal format",
                            "service": "BRAIN_ULTIMATE"
                        }
                    )
                
                # Pine Script ì‹ í˜¸ ì¶”ì 
                self.service_stats["pine_script_signals"] += 1
                
                # AI ë¶„ì„ ì‹¤í–‰ (ULTIMATE)
                analysis_result = await self.ai_engine.analyze_signal_complete(signal)
                
                # ğŸ»ğŸ‚ ì‹œì¥ë³„ ì‹ í˜¸ ì¶”ì 
                market_regime = analysis_result.technical_analysis.get("market_regime", "UNKNOWN")
                if market_regime == "BEAR_MARKET" and analysis_result.bear_market_score > 0.3:
                    self.service_stats["bear_market_signals"] += 1
                elif market_regime == "BULL_MARKET" and analysis_result.bull_market_score > 0.3:
                    self.service_stats["bull_market_signals"] += 1
                
                # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë©”ì‹œì§€ ë°œí–‰
                background_tasks.add_task(self._publish_results, signal, analysis_result)
                
                # ì„±ê³µ í†µê³„ ì—…ë°ì´íŠ¸
                if analysis_result.recommendation != "REJECT":
                    self.service_stats["successful_analyses"] += 1
                else:
                    self.service_stats["failed_analyses"] += 1
                
                # ì²˜ë¦¬ ì‹œê°„ ê³„ì‚°
                processing_time = (time.time() - webhook_start) * 1000
                
                # ì›¹í›… ì‘ë‹µ (TradingViewìš© ê°„ë‹¨ ì‘ë‹µ - ULTIMATE)
                response = {
                    "status": "success",
                    "signal_id": signal.signal_id,
                    "symbol": signal.symbol,
                    "recommendation": analysis_result.recommendation,
                    "confidence": analysis_result.final_confidence,
                    "kelly_fraction": analysis_result.kelly_fraction,
                    "market_regime": market_regime,
                    "bear_score": analysis_result.bear_market_score,  # ğŸ»
                    "bull_score": analysis_result.bull_market_score,  # ğŸ‚
                    "ultimate_analysis": True,  # ğŸ†• ULTIMATE ë§ˆí¬
                    "processing_time_ms": round(processing_time, 2),
                    "timestamp": time.time()
                }
                
                # ê³ í’ˆì§ˆ Pine Script ì‹ í˜¸ ë¡œê¹… (ULTIMATE)
                if analysis_result.final_confidence >= self.config.PHOENIX_95_CONFIG["confidence_threshold"]:
                    logging.info(
                        f"ğŸ¯ Pine Script ULTIMATE ê³ í’ˆì§ˆ ì‹ í˜¸: {signal.symbol} "
                        f"Alpha={signal.alpha_score} ML={signal.ml_signal} "
                        f"Confidence={analysis_result.final_confidence:.3f} "
                        f"Recommendation={analysis_result.recommendation} "
                        f"Regime={market_regime} "
                        f"ğŸ»{analysis_result.bear_market_score:.3f} "
                        f"ğŸ‚{analysis_result.bull_market_score:.3f}"
                    )
                
                return JSONResponse(content=response)
                
            except Exception as e:
                self.service_stats["failed_analyses"] += 1
                logging.error(f"ğŸ“¥ ULTIMATE ì›¹í›… ì²˜ë¦¬ ì‹¤íŒ¨: {e}\n{traceback.format_exc()}")
                
                return JSONResponse(
                    status_code=500,
                    content={
                        "status": "error",
                        "message": str(e),
                        "service": "BRAIN_ULTIMATE"
                    }
                )
        
        @self.app.get("/stats")
        async def get_statistics():
            """ì„œë¹„ìŠ¤ í†µê³„ ì¡°íšŒ (ULTIMATE)"""
            uptime = time.time() - self.service_stats["start_time"]
            ai_performance = self.ai_engine.get_performance_summary()
            
            return {
                "service": "BRAIN_ULTIMATE",
                "version": self.config.SERVICE_VERSION,
                "uptime_seconds": round(uptime, 2),
                "service_stats": self.service_stats,
                "ai_performance": ai_performance,
                "connections": {
                    "rabbitmq": self.mq_publisher.connected,
                    "redis_streams": self.stream_publisher.connected
                },
                "ultimate_features": {
                    "bull_bear_balanced": True,
                    "hmm_regime_detection": HMM_AVAILABLE,
                    "dynamic_position_sizing": True,
                    "enhanced_analysis": True
                },
                "timestamp": time.time()
            }
        
        @self.app.get("/config")
        async def get_configuration():
            """ì„œë¹„ìŠ¤ ì„¤ì • ì¡°íšŒ (ULTIMATE)"""
            return {
                "service": "BRAIN_ULTIMATE",
                "phoenix95_config": self.config.PHOENIX_95_CONFIG,
                "kelly_config": self.config.KELLY_CONFIG,
                "bear_market_config": self.config.BEAR_MARKET_CONFIG,
                "bull_market_config": self.config.BULL_MARKET_CONFIG,  # ğŸ†•
                "monitoring_config": self.config.MONITORING_CONFIG,
                "version": self.config.SERVICE_VERSION,
                "ultimate_features": True
            }
    
    async def _parse_tradingview_signal_ultimate(self, webhook_data: Dict) -> Optional[SignalData]:
        """ğŸ¯ TradingView Pine Script ì‹ í˜¸ íŒŒì‹± ULTIMATE - Bull/Bear ìµœì í™”"""
        try:
            # ê¸°ë³¸ í•„ìˆ˜ í•„ë“œ í™•ì¸
            if not all(key in webhook_data for key in ["symbol", "action", "price"]):
                logging.error("í•„ìˆ˜ í•„ë“œ ëˆ„ë½: symbol, action, price")
                return None
            
            # ì‹¬ë³¼ ì •ê·œí™”
            symbol = str(webhook_data["symbol"]).upper().strip()
            if not symbol:
                logging.error("ìœ íš¨í•˜ì§€ ì•Šì€ ì‹¬ë³¼")
                return None
            
            # ì•¡ì…˜ ì •ê·œí™”
            action = str(webhook_data["action"]).lower().strip()
            if action not in ["buy", "sell", "long", "short"]:
                logging.error(f"ìœ íš¨í•˜ì§€ ì•Šì€ ì•¡ì…˜: {action}")
                return None
            
            # ê°€ê²© ê²€ì¦
            try:
                price = float(webhook_data["price"])
                if price <= 0:
                    logging.error(f"ìœ íš¨í•˜ì§€ ì•Šì€ ê°€ê²©: {price}")
                    return None
            except (ValueError, TypeError):
                logging.error("ê°€ê²© íŒŒì‹± ì‹¤íŒ¨")
                return None
            
            # ê¸°ë³¸ ì‹ ë¢°ë„
            confidence = float(webhook_data.get("confidence", 0.75))
            confidence = max(0.0, min(1.0, confidence))
            
            # Pine Script IQE-V3 í•„ë“œë“¤ íŒŒì‹±
            alpha_score = None
            z_score = None
            ml_signal = None
            ml_confidence = None
            
            # Alpha Score íŒŒì‹±
            if "alpha_score" in webhook_data:
                try:
                    alpha_score = float(webhook_data["alpha_score"])
                    alpha_score = max(-1.0, min(1.0, alpha_score))
                except (ValueError, TypeError):
                    logging.warning("Alpha Score íŒŒì‹± ì‹¤íŒ¨")
            
            # Z-Score íŒŒì‹±
            if "z_score" in webhook_data:
                try:
                    z_score = float(webhook_data["z_score"])
                    z_score = max(-5.0, min(5.0, z_score))
                except (ValueError, TypeError):
                    logging.warning("Z-Score íŒŒì‹± ì‹¤íŒ¨")
            
            # ML Signal íŒŒì‹±
            if "ml_signal" in webhook_data:
                try:
                    ml_signal = float(webhook_data["ml_signal"])
                    ml_signal = max(-1.0, min(1.0, ml_signal))
                except (ValueError, TypeError):
                    logging.warning("ML Signal íŒŒì‹± ì‹¤íŒ¨")
            
            # ML Confidence íŒŒì‹±
            if "ml_confidence" in webhook_data:
                ml_conf_str = str(webhook_data["ml_confidence"]).lower().strip()
                valid_levels = ["very_high", "high", "medium", "low", "very_low"]
                if ml_conf_str in valid_levels:
                    ml_confidence = ml_conf_str
                else:
                    logging.warning(f"ìœ íš¨í•˜ì§€ ì•Šì€ ML Confidence: {ml_conf_str}")
            
            # ê¸°ìˆ ì  ì§€í‘œë“¤ íŒŒì‹±
            rsi = None
            macd = None
            volume = None
            
            if "rsi" in webhook_data:
                try:
                    rsi = float(webhook_data["rsi"])
                    rsi = max(0.0, min(100.0, rsi))
                except (ValueError, TypeError):
                    logging.warning("RSI íŒŒì‹± ì‹¤íŒ¨")
            
            if "macd" in webhook_data:
                try:
                    macd = float(webhook_data["macd"])
                except (ValueError, TypeError):
                    logging.warning("MACD íŒŒì‹± ì‹¤íŒ¨")
            
            if "volume" in webhook_data:
                try:
                    volume = float(webhook_data["volume"])
                    volume = max(0.0, volume)
                except (ValueError, TypeError):
                    logging.warning("Volume íŒŒì‹± ì‹¤íŒ¨")
            
            # ì¶”ê°€ ë©”íƒ€ë°ì´í„°
            strategy = webhook_data.get("strategy", "Pine_Script_IQE_V3_ULTIMATE")
            timeframe = webhook_data.get("timeframe", "1h")
            
            # SignalData ê°ì²´ ìƒì„±
            signal = SignalData(
                signal_id=f"PINE_ULTIMATE_{int(time.time() * 1000)}",
                symbol=symbol,
                action=action,
                price=price,
                confidence=confidence,
                timestamp=datetime.utcnow(),
                rsi=rsi,
                macd=macd,
                volume=volume,
                alpha_score=alpha_score,
                z_score=z_score,
                ml_signal=ml_signal,
                ml_confidence=ml_confidence,
                strategy=strategy,
                timeframe=timeframe,
                source="TradingView_Webhook_ULTIMATE"
            )
            
            # ğŸ†• ULTIMATE: ì‹œì¥ ì²´ì œ ê¸°ë°˜ ì‚¬ì „ ì‹ ë¢°ë„ ì¡°ì •
            market_regime = self.ai_engine.market_detector.detect_market_regime({
                "symbol": symbol,
                "price": price,
                "volume": volume,
                "rsi": rsi
            })
            
            # ULTIMATE ê· í˜•ì¡íŒ ì‹ ë¢°ë„ ì¡°ì • (Bull/Bear ëŒ€ì¹­)
            if market_regime == "BEAR_MARKET" and action in ["sell", "short"]:
                confidence = min(confidence * 1.15, 0.95)  # í•˜ë½ì¥ Short 15% ë¶€ìŠ¤íŠ¸
                logging.info(f"ğŸ» í•˜ë½ì¥ Short ì‹ í˜¸ ì‹ ë¢°ë„ ë¶€ìŠ¤íŠ¸: {confidence:.3f}")
            elif market_regime == "BULL_MARKET" and action in ["buy", "long"]:
                confidence = min(confidence * 1.15, 0.95)  # ìƒìŠ¹ì¥ Long 15% ë¶€ìŠ¤íŠ¸ (ëŒ€ì¹­)
                logging.info(f"ğŸ‚ ìƒìŠ¹ì¥ Long ì‹ í˜¸ ì‹ ë¢°ë„ ë¶€ìŠ¤íŠ¸: {confidence:.3f}")
            elif market_regime == "BEAR_MARKET" and action in ["buy", "long"]:
                confidence = confidence * 0.90  # í•˜ë½ì¥ Long 10% ê°ì†Œ
                logging.warning(f"ğŸ» í•˜ë½ì¥ Long ì‹ í˜¸ ì‹ ë¢°ë„ ê°ì†Œ: {confidence:.3f}")
            elif market_regime == "BULL_MARKET" and action in ["sell", "short"]:
                confidence = confidence * 0.90  # ìƒìŠ¹ì¥ Short 10% ê°ì†Œ (ëŒ€ì¹­)
                logging.warning(f"ğŸ‚ ìƒìŠ¹ì¥ Short ì‹ í˜¸ ì‹ ë¢°ë„ ê°ì†Œ: {confidence:.3f}")
            
            # ì‹ ë¢°ë„ ì—…ë°ì´íŠ¸
            signal.confidence = confidence
            
            # íŒŒì‹± ì„±ê³µ ë¡œê¹… (ULTIMATE)
            iqe_indicators = sum(1 for x in [alpha_score, z_score, ml_signal, ml_confidence] if x is not None)
            logging.info(
                f"âœ… Pine Script ULTIMATE ì‹ í˜¸ íŒŒì‹±: "
                f"{symbol} {action} @ {price} "
                f"Confidence={confidence:.3f} "
                f"IQE_Indicators={iqe_indicators} "
                f"Regime={market_regime}"
            )
            
            return signal
            
        except Exception as e:
            logging.error(f"ğŸš¨ Pine Script ULTIMATE ì‹ í˜¸ íŒŒì‹± ì˜¤ë¥˜: {e}\n{traceback.format_exc()}")
            return None
    
    async def _publish_results(self, signal: SignalData, result: AnalysisResult):
        """ë¶„ì„ ê²°ê³¼ ë°œí–‰ (ë°±ê·¸ë¼ìš´ë“œ) - ULTIMATE"""
        try:
            # RabbitMQ ë°œí–‰
            await self.mq_publisher.publish_analysis_result(signal, result)
            
            # Redis Streams ë°œí–‰
            await self.stream_publisher.publish_stream_data(signal, result)
            
            logging.info(
                f"ğŸ“¡ ULTIMATE ê²°ê³¼ ë°œí–‰ ì™„ë£Œ: {signal.symbol} -> {result.recommendation} "
                f"ğŸ»{result.bear_market_score:.3f} ğŸ‚{result.bull_market_score:.3f}"
            )
            
        except Exception as e:
            logging.error(f"ğŸ“¡ ULTIMATE ê²°ê³¼ ë°œí–‰ ì‹¤íŒ¨: {e}")
    
    def _generate_dashboard_html(self) -> str:
        """ëŒ€ì‹œë³´ë“œ HTML ìƒì„± (ULTIMATE - Bull/Bear ê· í˜• ì •ë³´ í¬í•¨)"""
        uptime = time.time() - self.service_stats["start_time"]
        uptime_str = str(timedelta(seconds=int(uptime)))
        ai_performance = self.ai_engine.get_performance_summary()
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>ğŸ§  BRAIN Service ULTIMATE + ğŸ»ğŸ‚ Bull/Bear + ğŸ“Š</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{ font-family: 'Segoe UI', Arial, sans-serif; margin: 0; background: linear-gradient(135deg, #1e3c72, #2a5298); color: #fff; }}
                .container {{ max-width: 1400px; margin: 0 auto; padding: 20px; }}
                .header {{ text-align: center; margin-bottom: 30px; }}
                .header h1 {{ font-size: 2.8em; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }}
                .header p {{ font-size: 1.2em; opacity: 0.9; }}
                .stats-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; }}
                .stat-card {{ background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border-radius: 15px; padding: 25px; border: 1px solid rgba(255,255,255,0.2); }}
                .stat-title {{ font-size: 1.4em; font-weight: bold; margin-bottom: 20px; color: #00ff88; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }}
                .stat-item {{ display: flex; justify-content: space-between; margin: 12px 0; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }}
                .stat-value {{ color: #00ff88; font-weight: bold; font-size: 1.1em; }}
                .status-indicator {{ display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; animation: pulse 2s infinite; }}
                .status-healthy {{ background: #00ff88; box-shadow: 0 0 10px #00ff88; }}
                .status-warning {{ background: #ffa500; box-shadow: 0 0 10px #ffa500; }}
                .footer {{ text-align: center; margin-top: 40px; opacity: 0.7; }}
                .pine-indicator {{ color: #ff6b35; font-weight: bold; text-shadow: 0 0 5px #ff6b35; }}
                .bear-indicator {{ color: #ff4444; font-weight: bold; text-shadow: 0 0 5px #ff4444; }}
                .bull-indicator {{ color: #10b981; font-weight: bold; text-shadow: 0 0 5px #10b981; }}
                .ultimate-badge {{ color: #ffd700; font-weight: bold; text-shadow: 0 0 10px #ffd700; }}
                @keyframes pulse {{ 0% {{ opacity: 1; }} 50% {{ opacity: 0.5; }} 100% {{ opacity: 1; }} }}
                .refresh-info {{ text-align: center; margin: 20px 0; opacity: 0.8; }}
                .balance-indicator {{ display: inline-block; padding: 4px 8px; border-radius: 12px; background: rgba(255,255,255,0.2); margin: 0 4px; }}
            </style>
            <script>
                setInterval(() => location.reload(), 30000);
            </script>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1><span class="ultimate-badge">ğŸ§  BRAIN Service ULTIMATE</span> + ğŸ»ğŸ‚ + ğŸ“Šâš¡</h1>
                    <p>Phoenix 95 Signal Intelligence Engine <span class="pine-indicator">+ Pine Script IQE-V3</span> <span class="bear-indicator">+ Bear Market</span> <span class="bull-indicator">+ Bull Market</span> <span style="color: #44ff44;">+ HMM ì²´ì œê°ì§€ + Dynamic Kelly</span></p>
                    <p><span class="status-indicator status-healthy"></span>ì„œë¹„ìŠ¤ ìƒíƒœ: <span class="ultimate-badge">ULTIMATE ëª¨ë“œ</span> ì •ìƒ ìš´ì˜ì¤‘ | ì—…íƒ€ì„: {uptime_str}</p>
                    <div>
                        <span class="balance-indicator bear-indicator">ğŸ» Bear Market</span>
                        <span class="balance-indicator" style="color: #888;">âš–ï¸ ê· í˜•</span>
                        <span class="balance-indicator bull-indicator">ğŸ‚ Bull Market</span>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-title">ğŸ“Š ì„œë¹„ìŠ¤ í†µê³„ (ULTIMATE)</div>
                        <div class="stat-item">
                            <span>í¬íŠ¸:</span>
                            <span class="stat-value">{self.config.SERVICE_PORT}</span>
                        </div>
                        <div class="stat-item">
                            <span>ì´ ìš”ì²­:</span>
                            <span class="stat-value">{self.service_stats["total_requests"]:,}</span>
                        </div>
                        <div class="stat-item">
                            <span>ì›¹í›… ìš”ì²­:</span>
                            <span class="stat-value pine-indicator">{self.service_stats["webhook_requests"]:,}</span>
                        </div>
                        <div class="stat-item">
                            <span>ì„±ê³µí•œ ë¶„ì„:</span>
                            <span class="stat-value">{self.service_stats["successful_analyses"]:,}</span>
                        </div>
                        <div class="stat-item">
                            <span>Pine Script ì‹ í˜¸:</span>
                            <span class="stat-value pine-indicator">{self.service_stats["pine_script_signals"]:,}</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ» í•˜ë½ì¥ ì‹ í˜¸:</span>
                            <span class="stat-value bear-indicator">{self.service_stats["bear_market_signals"]:,}</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ‚ ìƒìŠ¹ì¥ ì‹ í˜¸:</span>
                            <span class="stat-value bull-indicator">{self.service_stats["bull_market_signals"]:,}</span>
                        </div>
                        <div class="stat-item">
                            <span>ë²„ì „:</span>
                            <span class="stat-value ultimate-badge">{self.config.SERVICE_VERSION}</span>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-title">ğŸ§  AI ì—”ì§„ ì„±ëŠ¥ (ULTIMATE)</div>
                        <div class="stat-item">
                            <span>ì´ ë¶„ì„ ìˆ˜:</span>
                            <span class="stat-value">{ai_performance["total_analyses"]:,}</span>
                        </div>
                        <div class="stat-item">
                            <span>ì„±ê³µë¥ :</span>
                            <span class="stat-value">{ai_performance["success_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>Pine Script ë¹„ìœ¨:</span>
                            <span class="stat-value pine-indicator">{ai_performance["pine_script_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ» í•˜ë½ì¥ ë¹„ìœ¨:</span>
                            <span class="stat-value bear-indicator">{ai_performance["bear_market_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ‚ ìƒìŠ¹ì¥ ë¹„ìœ¨:</span>
                            <span class="stat-value bull-indicator">{ai_performance["bull_market_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ“Š HMM ê°ì§€ìœ¨:</span>
                            <span class="stat-value" style="color: #44ff44;">{ai_performance["hmm_detection_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸš€ í–¥ìƒëœ ğŸ»:</span>
                            <span class="stat-value" style="color: #44ff44;">{ai_performance["enhanced_bear_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸš€ í–¥ìƒëœ ğŸ‚:</span>
                            <span class="stat-value" style="color: #44ff44;">{ai_performance["enhanced_bull_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>âš¡ ë™ì  Kelly ì¡°ì •:</span>
                            <span class="stat-value" style="color: #44ff44;">{ai_performance["dynamic_kelly_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>ìºì‹œ íˆíŠ¸ìœ¨:</span>
                            <span class="stat-value">{ai_performance["cache_hit_rate"]}%</span>
                        </div>
                        <div class="stat-item">
                            <span>í‰ê·  ë¶„ì„ ì‹œê°„:</span>
                            <span class="stat-value">{ai_performance["avg_analysis_time_ms"]}ms</span>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-title">ğŸ“¡ ì—°ê²° ìƒíƒœ (ULTIMATE)</div>
                        <div class="stat-item">
                            <span>RabbitMQ:</span>
                            <span class="stat-value">{"âœ… ì—°ê²°ë¨" if self.mq_publisher.connected else "âŒ ì—°ê²° ì•ˆë¨"}</span>
                        </div>
                        <div class="stat-item">
                            <span>Redis Streams:</span>
                            <span class="stat-value">{"âœ… ì—°ê²°ë¨" if self.stream_publisher.connected else "âŒ ì—°ê²° ì•ˆë¨"}</span>
                        </div>
                        <div class="stat-item">
                            <span>TradingView ì›¹í›…:</span>
                            <span class="stat-value pine-indicator">âœ… ULTIMATE í™œì„±í™”</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ» í•˜ë½ì¥ ê°ì§€:</span>
                            <span class="stat-value bear-indicator">âœ… í™œì„±í™”</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ‚ ìƒìŠ¹ì¥ ê°ì§€:</span>
                            <span class="stat-value bull-indicator">âœ… í™œì„±í™”</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ“Š HMM ì²´ì œ ê°ì§€:</span>
                            <span class="stat-value" style="color: #44ff44;">{"âœ… í™œì„±í™”" if ai_performance["hmm_available"] else "âŒ ë¹„í™œì„±í™”"}</span>
                        </div>
                        <div class="stat-item">
                            <span>âš¡ Dynamic Kelly:</span>
                            <span class="stat-value" style="color: #44ff44;">âœ… ULTIMATE í™œì„±í™”</span>
                        </div>
                        <div class="stat-item">
                            <span>âš–ï¸ Bull/Bear ê· í˜•:</span>
                            <span class="stat-value ultimate-badge">âœ… ì™„ë²½ ëŒ€ì¹­</span>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-title">âš™ï¸ ULTIMATE ì„¤ì • ì •ë³´</div>
                        <div class="stat-item">
                            <span>ì‹ ë¢°ë„ ì„ê³„ê°’:</span>
                            <span class="stat-value">{self.config.PHOENIX_95_CONFIG["confidence_threshold"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>í’ˆì§ˆ ì„ê³„ê°’:</span>
                            <span class="stat-value">{self.config.PHOENIX_95_CONFIG["quality_threshold"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>Pine Script IQE ê°€ì¤‘ì¹˜:</span>
                            <span class="stat-value pine-indicator">{self.ai_engine.model_weights["pine_script_iqe"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ» í•˜ë½ì¥ ê°€ì¤‘ì¹˜:</span>
                            <span class="stat-value bear-indicator">{self.ai_engine.model_weights["bear_market_signals"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ‚ ìƒìŠ¹ì¥ ê°€ì¤‘ì¹˜:</span>
                            <span class="stat-value bull-indicator">{self.ai_engine.model_weights["bull_market_signals"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ“Š HMM ê°€ì¤‘ì¹˜:</span>
                            <span class="stat-value" style="color: #44ff44;">{self.ai_engine.model_weights["hmm_regime_analysis"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>ë¶„ì„ ì œí•œì‹œê°„:</span>
                            <span class="stat-value">{self.config.PHOENIX_95_CONFIG["analysis_timeout"]}ì´ˆ</span>
                        </div>
                        <div class="stat-item">
                            <span>ìµœëŒ€ Kelly:</span>
                            <span class="stat-value">{self.config.KELLY_CONFIG["max_kelly_fraction"]:.1%}</span>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-title">ğŸ¯ ULTIMATE íŠ¹í™” ê¸°ëŠ¥</div>
                        <div class="stat-item">
                            <span>ğŸ» Bear Market ë¶€ìŠ¤íŠ¸:</span>
                            <span class="stat-value bear-indicator">{self.config.BEAR_MARKET_CONFIG["short_boost_factor"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ‚ Bull Market ë¶€ìŠ¤íŠ¸:</span>
                            <span class="stat-value bull-indicator">{self.config.BULL_MARKET_CONFIG["long_boost_factor"]:.1%}</span>
                        </div>
                        <div class="stat-item">
                            <span>âš–ï¸ ì™„ë²½í•œ ëŒ€ì¹­ êµ¬ì¡°:</span>
                            <span class="stat-value ultimate-badge">âœ… 8.5% vs 8.5%</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸš€ í–¥ìƒëœ ë¶„ì„:</span>
                            <span class="stat-value ultimate-badge">âœ… ~0.001ì´ˆ</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ“Š HMM 3-ìƒíƒœ:</span>
                            <span class="stat-value" style="color: #44ff44;">âœ… Bear/Side/Bull</span>
                        </div>
                        <div class="stat-item">
                            <span>âš¡ Dynamic Position:</span>
                            <span class="stat-value" style="color: #44ff44;">âœ… ì‹œì¥ë³„ ìµœì í™”</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ¯ Pine IQE-V3:</span>
                            <span class="stat-value pine-indicator">âœ… 4ê°œ ì§€í‘œ</span>
                        </div>
                        <div class="stat-item">
                            <span>ğŸ”„ ìë™ ì²´ì œ ê°ì§€:</span>
                            <span class="stat-value ultimate-badge">âœ… ì‹¤ì‹œê°„</span>
                        </div>
                    </div>
                </div>
                
                <div class="refresh-info">
                    <p>ğŸ”„ 30ì´ˆë§ˆë‹¤ ìë™ ìƒˆë¡œê³ ì¹¨ | ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | <span class="ultimate-badge">ULTIMATE ëª¨ë“œ</span></p>
                </div>
                
                <div class="footer">
                    <p><span class="ultimate-badge">ğŸ§  BRAIN Service ULTIMATE</span> - Phoenix 95 Signal Intelligence Engine</p>
                    <p>ğŸ»ğŸ‚ ì™„ë²½í•œ Bull/Bear ê· í˜• ë¶„ì„ | ğŸ“Š HMM ì²´ì œ ê°ì§€ | âš¡ Dynamic Position Sizing | <span class="pine-indicator">Pine Script IQE-V3 ì—°ë™</span></p>
                    <p>85% ì´ìƒ ì‹ ë¢°ë„ ì‹ í˜¸ ì²˜ë¦¬ | Kelly Criterion í¬ì§€ì…˜ ì‚¬ì´ì§• | <span class="bear-indicator">í•˜ë½ì¥ ê°ì§€ ë° ìµœì í™”</span> | <span class="bull-indicator">ìƒìŠ¹ì¥ ê°ì§€ ë° ìµœì í™”</span></p>
                    <p>ì›¹í›… URL: <span class="pine-indicator">http://localhost:{self.config.SERVICE_PORT}/webhook</span> | <span class="ultimate-badge">ULTIMATE API</span></p>
                </div>
            </div>
        </body>
        </html>
        """
        
        return html
    
    async def start_background_services(self):
        """ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ì‹œì‘ (ULTIMATE)"""
        logging.info("ğŸ”„ ULTIMATE ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ì‹œì‘")
        
        # ë©”ì‹œì§€ í ì—°ê²°
        await self.mq_publisher.connect()
        
        # Redis Streams ì—°ê²°
        await self.stream_publisher.connect()
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬
        monitor_task = asyncio.create_task(self._performance_monitoring_loop())
        self.background_tasks.append(monitor_task)
        
        # ë©”ëª¨ë¦¬ ì •ë¦¬ íƒœìŠ¤í¬
        cleanup_task = asyncio.create_task(self._memory_cleanup_loop())
        self.background_tasks.append(cleanup_task)
        
        logging.info(f"âœ… ULTIMATE {len(self.background_tasks)}ê°œ ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ ì‹œì‘ë¨")
    
    async def _performance_monitoring_loop(self):
        """ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë£¨í”„ (ULTIMATE)"""
        while True:
            try:
                await asyncio.sleep(self.config.MONITORING_CONFIG["metrics_interval"])
                
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                memory_percent = psutil.virtual_memory().percent
                cpu_percent = psutil.cpu_percent()
                
                # ì•Œë¦¼ ì„ê³„ê°’ ì²´í¬
                alerts = []
                thresholds = self.config.MONITORING_CONFIG["alert_thresholds"]
                
                if memory_percent > thresholds["memory_percent"]:
                    alerts.append(f"ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {memory_percent:.1f}%")
                
                if cpu_percent > thresholds["cpu_percent"]:
                    alerts.append(f"ë†’ì€ CPU ì‚¬ìš©ë¥ : {cpu_percent:.1f}%")
                
                ai_performance = self.ai_engine.get_performance_summary()
                if ai_performance["avg_analysis_time_ms"] > thresholds["response_time_ms"]:
                    alerts.append(f"ëŠë¦° ì‘ë‹µì‹œê°„: {ai_performance['avg_analysis_time_ms']:.1f}ms")
                
                # ì•Œë¦¼ ë¡œê¹…
                for alert in alerts:
                    logging.warning(f"âš ï¸ BRAIN ULTIMATE ì„±ëŠ¥ ì•Œë¦¼: {alert}")
                
            except Exception as e:
                logging.error(f"ULTIMATE ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: {e}")
    
    async def _memory_cleanup_loop(self):
        """ë©”ëª¨ë¦¬ ì •ë¦¬ ë£¨í”„ (ULTIMATE)"""
        while True:
            try:
                await asyncio.sleep(300)  # 5ë¶„ë§ˆë‹¤
                
                # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜
                collected = gc.collect()
                
                # ìºì‹œ ì •ë¦¬
                current_time = time.time()
                cache_duration = self.config.PHOENIX_95_CONFIG["cache_duration"]
                
                expired_keys = [
                    key for key, (_, timestamp) in self.ai_engine.analysis_cache.items()
                    if current_time - timestamp > cache_duration
                ]
                
                for key in expired_keys:
                    del self.ai_engine.analysis_cache[key]
                
                if collected > 0 or expired_keys:
                    logging.info(f"ğŸ§¹ ULTIMATE ë©”ëª¨ë¦¬ ì •ë¦¬: GC={collected}, ìºì‹œ={len(expired_keys)}")
                
            except Exception as e:
                logging.error(f"ULTIMATE ë©”ëª¨ë¦¬ ì •ë¦¬ ì˜¤ë¥˜: {e}")
    
    async def stop_background_services(self):
        """ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ì •ì§€ (ULTIMATE)"""
        logging.info("ğŸ›‘ ULTIMATE ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ì •ì§€")
        
        # ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ ì·¨ì†Œ
        for task in self.background_tasks:
            task.cancel()
        
        # ì—°ê²° ì¢…ë£Œ
        await self.mq_publisher.disconnect()
        await self.stream_publisher.disconnect()
        
        logging.info("âœ… ULTIMATE ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ì •ì§€ ì™„ë£Œ")

# =============================================================================
# ğŸš€ ë©”ì¸ ì‹¤í–‰ë¶€ (ULTIMATE)
# =============================================================================

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜ (ULTIMATE)"""
    try:
        # ë¡œê¹… ì„¤ì •
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - [ğŸ§ ULTIMATEğŸ»ğŸ‚ğŸ“Šâš¡] %(message)s',
            handlers=[
                logging.FileHandler('brain_service_ultimate.log', encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        # BRAIN ì„œë¹„ìŠ¤ ULTIMATE ì´ˆê¸°í™”
        brain_service = BrainService()
        
        # ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ì‹œì‘
        await brain_service.start_background_services()
        
        # ì‹œì‘ ë©”ì‹œì§€ (ULTIMATE)
        logging.info("ğŸ§  BRAIN Service ULTIMATE ì‹œì‘ (Pine + ğŸ»ğŸ‚ Bull/Bear + ğŸ“Š HMM + âš¡ Dynamic)")
        logging.info(f"ğŸ“¡ í¬íŠ¸: {brain_service.config.SERVICE_PORT}")
        logging.info(f"ğŸ¯ Phoenix 95 ì‹ ë¢°ë„ ì„ê³„ê°’: {brain_service.config.PHOENIX_95_CONFIG['confidence_threshold']:.1%}")
        logging.info(f"ğŸ“Š í’ˆì§ˆ ì„ê³„ê°’: {brain_service.config.PHOENIX_95_CONFIG['quality_threshold']:.1%}")
        logging.info(f"ğŸ”— Pine Script IQE ê°€ì¤‘ì¹˜: {brain_service.ai_engine.model_weights['pine_script_iqe']:.1%}")
        logging.info(f"ğŸ» í•˜ë½ì¥ ê°€ì¤‘ì¹˜: {brain_service.ai_engine.model_weights['bear_market_signals']:.1%}")
        logging.info(f"ğŸ‚ ìƒìŠ¹ì¥ ê°€ì¤‘ì¹˜: {brain_service.ai_engine.model_weights['bull_market_signals']:.1%}")
        logging.info(f"ğŸ“Š HMM ì²´ì œ ê°ì§€: {'âœ… í™œì„±í™”' if HMM_AVAILABLE else 'âŒ ë¹„í™œì„±í™”'}")
        logging.info(f"âš¡ Dynamic Position Sizing: âœ… ULTIMATE í™œì„±í™”")
        logging.info(f"âš–ï¸ Bull/Bear ê· í˜•: âœ… ì™„ë²½í•œ ëŒ€ì¹­ êµ¬ì¡° (8.5% vs 8.5%)")
        logging.info(f"ğŸ° RabbitMQ: {'âœ…' if brain_service.mq_publisher.connected else 'âŒ'}")
        logging.info(f"ğŸ”´ Redis: {'âœ…' if brain_service.stream_publisher.connected else 'âŒ'}")
        logging.info(f"ğŸ“¥ ì›¹í›… URL: http://localhost:{brain_service.config.SERVICE_PORT}/webhook")
        logging.info(f"ğŸš€ ULTIMATE ê¸°ëŠ¥: ğŸ»ğŸ‚ ì™„ë²½ ëŒ€ì¹­ + ğŸ“Š HMM + âš¡ Dynamic Kelly")
        if not HMM_AVAILABLE:
            logging.warning("ğŸ“Š HMM ì‚¬ìš©í•˜ë ¤ë©´: pip install hmmlearn")
        
        # ì„œë²„ ì‹¤í–‰
        config = uvicorn.Config(
            brain_service.app,
            host="0.0.0.0",
            port=brain_service.config.SERVICE_PORT,
            log_level="info",
            access_log=True
        )
        
        server = uvicorn.Server(config)
        await server.serve()
        
    except KeyboardInterrupt:
        logging.info("ğŸ›‘ ì‚¬ìš©ìì— ì˜í•œ ULTIMATE ì„œë¹„ìŠ¤ ì¢…ë£Œ")
    except Exception as e:
        logging.error(f"âŒ ULTIMATE ì„œë¹„ìŠ¤ ì‹¤í–‰ ì˜¤ë¥˜: {e}\n{traceback.format_exc()}")
    finally:
        # ì •ë¦¬
        if 'brain_service' in locals():
            await brain_service.stop_background_services()
        logging.info("ğŸ‘‹ BRAIN Service ULTIMATE ì¢…ë£Œ")

if __name__ == "__main__":
    asyncio.run(main())

# =============================================================================
# ğŸ“‹ ì‚¬ìš©ë²• ë° API ì˜ˆì œ (ULTIMATE - Bull/Bear + HMM + Dynamic)
# =============================================================================

"""
ğŸ§  BRAIN Service ULTIMATE ì‚¬ìš©ë²• (Pine Script IQE-V3 + ğŸ»ğŸ‚ Bull/Bear ê· í˜• + ğŸ“Š HMM + âš¡ Dynamic Kelly):

ğŸ“Œ ìƒˆë¡œìš´ ULTIMATE ê¸°ëŠ¥ë“¤:
âœ… ğŸ‚ Bull Market ë¶„ì„ê¸° ì¶”ê°€ - Bear Marketê³¼ ì™„ë²½í•œ ëŒ€ì¹­ êµ¬ì¡°
âœ… âš–ï¸ Bull/Bear ê· í˜• (ê°ê° 8.5% ê°€ì¤‘ì¹˜ë¡œ ë™ë“±í•˜ê²Œ ê¸°ì—¬)
âœ… ğŸš€ í–¥ìƒëœ Bull/Bear ë¶„ì„ (ì´ˆê³ ì† ~0.001ì´ˆ ì²˜ë¦¬)
âœ… ğŸ“Š HMM 3-ìƒíƒœ ëª¨ë¸ (Bear/Sideways/Bull ì‹¤ì‹œê°„ ê°ì§€)
âœ… âš¡ Dynamic Position Sizing (ì‹œì¥ ì²´ì œë³„ Kelly ìµœì í™”)
âœ… ğŸ¯ ì™„ë²½í•œ ëŒ€ì¹­ ì‹ í˜¸ ì¡°ì • (Bull Long ë¶€ìŠ¤íŠ¸ â†” Bear Short ë¶€ìŠ¤íŠ¸)

1. ì„œë¹„ìŠ¤ ì‹œì‘:
   python brain_service_ultimate.py
   
   ğŸ†• ULTIMATE ê¸°ëŠ¥ í™œì„±í™”í•˜ë ¤ë©´:
   pip install hmmlearn numpy

2. ì¼ë°˜ API í˜¸ì¶œ ì˜ˆì œ (ULTIMATE):
   curl -X POST "http://localhost:8100/analyze" \
        -H "Content-Type: application/json" \
        -d '{
            "symbol": "BTCUSDT",
            "action": "buy",
            "price": 45000.0,
            "confidence": 0.8,
            "rsi": 35.5,
            "macd": 0.003,
            "volume": 1500000,
            "alpha_score": 0.75,
            "z_score": 2.1,
            "ml_signal": 0.85,
            "ml_confidence": "high"
        }'

3. ğŸ†• Pine Script ì›¹í›… ì˜ˆì œ (ULTIMATE - Bull/Bear ê· í˜•):
   curl -X POST "http://localhost:8100/webhook" \
        -H "Content-Type: application/json" \
        -d '{
            "symbol": "BTCUSDT",
            "action": "buy",
            "price": 47000.0,
            "confidence": 0.85,
            "alpha_score": 0.8,
            "z_score": 2.5,
            "ml_signal": 0.9,
            "ml_confidence": "very_high",
            "strategy": "Pine_Script_IQE_V3_ULTIMATE",
            "timeframe": "1h",
            "rsi": 30,
            "macd": 0.005,
            "volume": 8000000
        }'

4. TradingView Pine Script ì›¹í›… ì„¤ì • (ULTIMATE):
   - URL: http://your-server:8100/webhook
   - Method: POST
   - Content-Type: application/json
   - Body: {"symbol":"{{ticker}}", "action":"{{strategy.order.action}}", "price":"{{close}}", "alpha_score":"{{plot_0}}", "z_score":"{{plot_1}}", "ml_signal":"{{plot_2}}", "ml_confidence":"very_high", "rsi":"{{rsi}}", "macd":"{{macd}}", "volume":"{{volume}}"}

5. í—¬ìŠ¤ì²´í¬ (ULTIMATE):
   curl http://localhost:8100/health

6. í†µê³„ ì¡°íšŒ (ULTIMATE):
   curl http://localhost:8100/stats

7. ëŒ€ì‹œë³´ë“œ ì ‘ì† (ULTIMATE):
   http://localhost:8100

ğŸ“¡ ë©”ì‹œì§€ í ì„¤ì • (ULTIMATE):
- RabbitMQ Exchange: phoenix95.brain.analysis
- Redis Stream: brain:analysis:stream
- ULTIMATE ë¶„ì„ ê²°ê³¼ê°€ ìë™ìœ¼ë¡œ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ë¡œ ì „ë‹¬ë©ë‹ˆë‹¤.

ğŸ¯ Pine Script IQE-V3 í•µì‹¬ ê¸°ëŠ¥ (ULTIMATE):
- Alpha Score ë¶„ì„ (-1 ~ 1 ë²”ìœ„)
- Z-Score ì •ê·œí™” (-5 ~ 5 ë²”ìœ„)
- ML Signal ê°•ë„ (-1 ~ 1 ë²”ìœ„)
- ML Confidence ë ˆë²¨ (very_high, high, medium, low, very_low)
- ê°€ì¤‘ì¹˜ ê¸°ë°˜ í†µí•© ë¶„ì„ (20% ê°€ì¤‘ì¹˜)
- Kelly Criterionì— IQE ì‹ í˜¸ ë°˜ì˜
- ì‹¤ì‹œê°„ Pine Script ì›¹í›… ì²˜ë¦¬

ğŸ»ğŸ‚ Bull/Bear Market ULTIMATE ê¸°ëŠ¥:
âœ… ì‹¤ì‹œê°„ ì‹œì¥ ì²´ì œ ê°ì§€ (BEAR_MARKET, BULL_MARKET, SIDEWAYS)
âœ… ğŸ» í•˜ë½ì¥ì—ì„œ Short ì‹ í˜¸ 20% ë¶€ìŠ¤íŠ¸ + Long ì‹ í˜¸ 15% í˜ë„í‹°
âœ… ğŸ‚ ìƒìŠ¹ì¥ì—ì„œ Long ì‹ í˜¸ 20% ë¶€ìŠ¤íŠ¸ + Short ì‹ í˜¸ 15% í˜ë„í‹° (ì™„ë²½í•œ ëŒ€ì¹­!)
âœ… RSI ê³¼ë§¤ë„/ê³¼ë§¤ìˆ˜ ë°˜ì „ ì‹ í˜¸ ê°•í™”
âœ… ì €í•­ì„ /ì§€ì§€ì„  ëŒíŒŒ/ì´íƒˆ ê°ì§€
âœ… FOMO ë§¤ìˆ˜/ê³µí¬ ë§¤ë„ íŒ¨í„´ ë¶„ì„
âœ… MACD ìƒìŠ¹/í•˜ë½ ëª¨ë©˜í…€ ë¶„ì„
âœ… íƒìš•/ê³µí¬ ì§€ìˆ˜ í™œìš©
âœ… ì—°ì† ìƒìŠ¹/í•˜ë½ íŒ¨í„´ ê°ì§€
âœ… Bull/Bear ì „ìš© ë¦¬ìŠ¤í¬ ê´€ë¦¬
âœ… Pine Script ì›¹í›…ì—ì„œ ìë™ ì‹œì¥ë³„ ì‹ ë¢°ë„ ì¡°ì •

ğŸ“Š HMM ì²´ì œ ê°ì§€ (ULTIMATE):
âœ… GaussianHMM 3-ìƒíƒœ ëª¨ë¸ (í•˜ë½ì¥/íš¡ë³´ì¥/ìƒìŠ¹ì¥)
âœ… ê°€ê²© ìˆ˜ìµë¥ , ê±°ë˜ëŸ‰, RSI ê¸°ë°˜ íŠ¹ì„± ë²¡í„°
âœ… ì‹¤ì‹œê°„ ìƒíƒœ ì˜ˆì¸¡ (~0.1ì´ˆ ì²˜ë¦¬)
âœ… 30ì´ˆ ìºì‹±ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™”
âœ… ê¸°ì¡´ ë°©ì‹ ë°±ì—… ì§€ì›
âœ… 8% ê°€ì¤‘ì¹˜ë¡œ Phoenix 95 ì ìˆ˜ì— ê¸°ì—¬

ğŸš€ í–¥ìƒëœ Bull/Bear ë¶„ì„ (ULTIMATE):
âœ… ì´ˆê³ ì† ì²˜ë¦¬ (~0.001ì´ˆ)
âœ… ğŸ» RSI ê³¼ë§¤ìˆ˜ ì‹ í˜¸ + MACD í•˜ë½ ëª¨ë©˜í…€ + ê±°ë˜ëŸ‰ ìŠ¤íŒŒì´í¬ ê°ì§€
âœ… ğŸ‚ RSI ê³¼ë§¤ë„ ì‹ í˜¸ + MACD ìƒìŠ¹ ëª¨ë©˜í…€ + ì €í•­ì„  ëŒíŒŒ ê°ì§€
âœ… Pine Script Alpha/ML ì‹ í˜¸ í†µí•©
âœ… Z-Score ê·¹ê°’ ì²´í¬
âœ… ëŒ€ì¹­ì  ì‹ í˜¸ ê°•ë„ ê³„ì‚°

âš¡ Dynamic Position Sizing ULTIMATE:
âœ… ì‹œì¥ ì²´ì œë³„ Kelly ì¡°ì •
âœ… ğŸ» í•˜ë½ì¥: 30% ì¶•ì†Œ (ë³´ìˆ˜ì ) - Bear score ë†’ìœ¼ë©´ ëœ ë³´ìˆ˜ì 
âœ… ğŸ‚ ìƒìŠ¹ì¥: 25% í™•ëŒ€ (ì ê·¹ì ) - Bull score ë†’ìœ¼ë©´ ë” ì ê·¹ì 
âœ… íš¡ë³´ì¥: 10% ì¶•ì†Œ (ì‹ ì¤‘í•¨)
âœ… ë³€ë™ì„± ë° ê¸°ìˆ ë¶„ì„ í’ˆì§ˆ ë°˜ì˜
âœ… Bull/Bear ì ìˆ˜ ê¸°ë°˜ ì¶”ê°€ ì¡°ì •
âœ… ì‹¤ì‹œê°„ ì¡°ì • ë¡œê¹…

ğŸ”— ULTIMATE ì—°ë™ í”Œë¡œìš°:
Pine Script â†’ TradingView ì›¹í›… â†’ ğŸ»ğŸ‚ ì‹œì¥ ì²´ì œ ê°ì§€ â†’ ğŸ“Š HMM 3-ìƒíƒœ ë¶„ì„ â†’ BRAIN ULTIMATE â†’ Phoenix 95 AI ë¶„ì„ â†’ âš¡ Dynamic Kelly â†’ ëŒ€ì¹­ì  ì‹œì¥ ì¡°ì • â†’ RabbitMQ/Redis â†’ ë‹¤ìš´ìŠ¤íŠ¸ë¦¼ ì„œë¹„ìŠ¤

âš¡ ULTIMATE ì„±ëŠ¥ ìµœì í™”:
âœ… ìºì‹œ ê¸°ë°˜ ë¹ ë¥¸ ì‘ë‹µ
âœ… ë¹„ë™ê¸° ë©”ì‹œì§€ ë°œí–‰
âœ… ë°±ê·¸ë¼ìš´ë“œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
âœ… ìë™ ë©”ëª¨ë¦¬ ê´€ë¦¬
âœ… Pine Script ì‹ í˜¸ ìš°ì„ ìˆœìœ„ ì²˜ë¦¬
âœ… ğŸ»ğŸ‚ ëŒ€ì¹­ì  ì‹ í˜¸ íŠ¹ë³„ ì²˜ë¦¬
âœ… ğŸ“Š HMM 30ì´ˆ ìºì‹±
âœ… ğŸš€ í–¥ìƒëœ Bull/Bear ë¶„ì„ ì´ˆê³ ì† ì²˜ë¦¬ (~0.001ì´ˆ)
âœ… âš¡ Dynamic Kelly ì‹¤ì‹œê°„ ì¡°ì •

ğŸ»ğŸ‚ ULTIMATE ê· í˜• í™œìš© íŒ:
1. **ìƒìŠ¹ì¥ (Bull Market)**:
   - Long í¬ì§€ì…˜ì„ ë” ì ê·¹ì ìœ¼ë¡œ í™œìš© (20% ë¶€ìŠ¤íŠ¸)
   - Short í¬ì§€ì…˜ì˜ ì‹ ë¢°ë„ë¥¼ ë³´ìˆ˜ì ìœ¼ë¡œ í‰ê°€ (15% í˜ë„í‹°)
   - RSI ê³¼ë§¤ë„ì—ì„œ ë°˜ë“± íŒ¨í„´ ê°•í™”
   - ì €í•­ì„  ëŒíŒŒì‹œ ëª¨ë©˜í…€ ì‹ í˜¸ë¡œ ì¸ì‹
   - FOMO ë§¤ìˆ˜ íŒ¨í„´ ê°ì§€ ë° í™œìš©

2. **í•˜ë½ì¥ (Bear Market)**: 
   - Short í¬ì§€ì…˜ì„ ë” ì ê·¹ì ìœ¼ë¡œ í™œìš© (20% ë¶€ìŠ¤íŠ¸)
   - Long í¬ì§€ì…˜ì˜ ì‹ ë¢°ë„ë¥¼ ë³´ìˆ˜ì ìœ¼ë¡œ í‰ê°€ (15% í˜ë„í‹°)
   - RSI ê³¼ë§¤ìˆ˜ì—ì„œ ì—­ë°œì‚° íŒ¨í„´ ê°•í™”
   - ì§€ì§€ì„  ì´íƒˆì‹œ ë¶•ê´´ ì‹ í˜¸ë¡œ ì¸ì‹
   - ê³µí¬ ë§¤ë„ íŒ¨í„´ ê°ì§€ ë° í™œìš©

3. **íš¡ë³´ì¥ (Sideways)**:
   - ì–‘ë°©í–¥ ëª¨ë‘ ì‹ ì¤‘í•œ ì ‘ê·¼ (10% ë³´ìˆ˜ì  ì¡°ì •)
   - ë²”ìœ„ ê±°ë˜ ì „ëµ í™œìš©
   - ë¸Œë ˆì´í¬ì•„ì›ƒ ëŒ€ê¸°

4. **ğŸ“Š HMM í™œìš©**:
   - ì‹¤ì‹œê°„ ì²´ì œ ë³€í™” ê°ì§€
   - 30ì´ˆ ìºì‹±ìœ¼ë¡œ íš¨ìœ¨ì  ì²˜ë¦¬
   - ì „í†µì  ë°©ì‹ê³¼ ì¡°í•©ìœ¼ë¡œ ì •í™•ë„ í–¥ìƒ

5. **âš¡ Dynamic Kelly í™œìš©**:
   - ì‹œì¥ë³„ í¬ì§€ì…˜ í¬ê¸° ìë™ ìµœì í™”
   - Bull/Bear ì ìˆ˜ ê¸°ë°˜ ì„¸ë°€í•œ ì¡°ì •
   - ë¦¬ìŠ¤í¬ ê´€ë¦¬ ìë™í™”

ğŸ› ï¸ ULTIMATE ê¸°ëŠ¥ ì„¤ì¹˜:
pip install hmmlearn numpy  # HMM ì²´ì œ ê°ì§€ + ê³ ì„±ëŠ¥ ê³„ì‚°

ğŸ”¥ ULTIMATE ì—…ê·¸ë ˆì´ë“œ í•˜ì´ë¼ì´íŠ¸:
âœ… ğŸ‚ Bull Market ë¶„ì„ê¸° - Bearì™€ ì™„ë²½í•œ ëŒ€ì¹­ êµ¬ì¡° êµ¬í˜„
âœ… âš–ï¸ ì™„ë²½í•œ ê· í˜• - Bull/Bear ê°ê° 8.5% ê°€ì¤‘ì¹˜ë¡œ ë™ë“±í•œ ê¸°ì—¬
âœ… ğŸš€ í–¥ìƒëœ ì–‘ë°©í–¥ ë¶„ì„ - ì²˜ë¦¬ì‹œê°„ ~0.001ì´ˆ ì´ˆê³ ì†
âœ… ğŸ“Š HMM 3-ìƒíƒœ ëª¨ë¸ - ì‹¤ì‹œê°„ Bear/Sideways/Bull ê°ì§€
âœ… âš¡ Dynamic Position Sizing - ì‹œì¥ ì²´ì œë³„ Kelly ìµœì í™”
âœ… ğŸ¯ ëŒ€ì¹­ì  ì‹ í˜¸ ì¡°ì • - Bull Long ë¶€ìŠ¤íŠ¸ â†” Bear Short ë¶€ìŠ¤íŠ¸
âœ… ì‹¤ì‹œê°„ ì„±ëŠ¥ ë©”íŠ¸ë¦­ - Bull/Bear/HMM/Dynamic ëª¨ë“  ê¸°ëŠ¥ ì¶”ì 
âœ… ULTIMATE ëŒ€ì‹œë³´ë“œ - ìƒˆ ê¸°ëŠ¥ í†µê³„ ì™„ë²½ í‘œì‹œ
âœ… ì™„ì „í•œ API ì‘ë‹µ - Bull/Bear ì ìˆ˜ í¬í•¨

ğŸŠ ì¶•í•˜í•©ë‹ˆë‹¤! ì´ì œ ì™„ë²½í•˜ê²Œ ê· í˜•ì¡íŒ ULTIMATE BRAIN Serviceê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!
ğŸ» Bear Market â†” ğŸ‚ Bull Market ì™„ë²½í•œ ëŒ€ì¹­ êµ¬ì¡°
ğŸ“Š HMM ì²´ì œ ê°ì§€ + âš¡ Dynamic Position Sizing
ğŸ¯ Pine Script IQE-V3 + Phoenix 95 AI Engine
"""